**目录：**

- [1. 简介](#1-简介)
  - [1.1. 要求记号](#11-要求记号)
  - [1.2. 语法记号](#12-语法记号)
- [2. 架构](#2-架构)
  - [2.1. 客户/服务器交换报文](#21-客户服务器交换报文)
  - [2.2. 实现多样性](#22-实现多样性)
  - [2.3. 中继](#23-中继)
  - [2.4. 缓存](#24-缓存)
  - [2.5. 符合性和错误处理](#25-符合性和错误处理)
  - [2.6. 协议版本](#26-协议版本)
  - [2.7. 统一资源标识符(URI)](#27-统一资源标识符uri)
    - [2.7.1. http URI 方案](#271-http-uri-方案)
    - [2.7.2. https URI 方案](#272-https-uri-方案)
    - [2.7.3. http 和 https URI 的标准化和比较](#273-http-和-https-uri-的标准化和比较)
- [3. 报文格式](#3-报文格式)
  - [3.1. 起始行](#31-起始行)
    - [3.1.1. 请求行](#311-请求行)
    - [3.1.2. 状态行](#312-状态行)
  - [3.2. 首部字段](#32-首部字段)
    - [3.2.1. 字段扩展性](#321-字段扩展性)
    - [3.2.2. 字段顺序](#322-字段顺序)
    - [3.2.3. 空白](#323-空白)
    - [3.2.4. 字段解析](#324-字段解析)
    - [3.2.5. 字段限制](#325-字段限制)
    - [3.2.6. 字段值部分](#326-字段值部分)
  - [3.3. 报文体](#33-报文体)
    - [3.3.1. Transfer-Encoding](#331-transfer-encoding)
    - [3.3.2. Content-Length](#332-content-length)
    - [3.3.3. 报文体长度](#333-报文体长度)
  - [3.4. 处理不完整的报文](#34-处理不完整的报文)
  - [3.5. 报文解析健壮性](#35-报文解析健壮性)
- [4. 传输编码](#4-传输编码)
  - [4.1. 分块传输编码](#41-分块传输编码)
    - [4.1.1. 块扩展](#411-块扩展)
    - [4.1.2. 分块 Trailer-Part](#412-分块-trailer-part)
    - [4.1.3. 解码分块](#413-解码分块)
  - [4.2. 压缩编码](#42-压缩编码)
    - [4.2.1. Compress 编码](#421-compress-编码)
    - [4.2.2. Deflate 编码](#422-deflate-编码)
    - [4.2.3. Gzip 编码](#423-gzip-编码)
  - [4.3. TE](#43-te)
  - [4.4. Trailer](#44-trailer)
- [5. 报文路由](#5-报文路由)
  - [5.1. 识别目标资源](#51-识别目标资源)
  - [5.2. 连接入站](#52-连接入站)
  - [5.3. 请求目标](#53-请求目标)
    - [5.3.1. 原始形式](#531-原始形式)
    - [5.3.2. 绝对形式](#532-绝对形式)
    - [5.3.3. 权威形式](#533-权威形式)
    - [5.3.4. 星号形式](#534-星号形式)
  - [5.4. Host](#54-host)
  - [5.5. 有效请求 URI](#55-有效请求-uri)
  - [5.6. 关联请求和响应](#56-关联请求和响应)
  - [5.7. 报文转发](#57-报文转发)
    - [5.7.1. Via](#571-via)
    - [5.7.2. 转译](#572-转译)
- [6. 连接管理](#6-连接管理)
  - [6.1. Connection](#61-connection)
  - [6.2. 建立](#62-建立)
  - [6.3. 持续](#63-持续)
    - [6.3.1. 重试请求](#631-重试请求)
    - [6.3.2. 流水线](#632-流水线)
  - [6.4. 并发](#64-并发)
  - [6.5. 失败和超时](#65-失败和超时)
  - [6.6. 拆除](#66-拆除)
  - [6.7. Upgrade](#67-upgrade)
- [7. ABNF 列表扩展：#规则](#7-abnf-列表扩展规则)

# 1. 简介

**超文本传输协议(Hypertext Transfer Protocol, HTTP)** 是一个无状态的应用层请求/响应协议，它使用可扩展的语义和自我描述的报文有效载荷，与基于网络的超文本信息系统进行灵活的交互。本文档是一系列文档中的第一个，这些文档共同构成了 HTTP/1.1 规范：

1. “报文语法和路由”(本文档)
2. “语义和内容” [RFC7231]
3. “条件请求” [RFC7232]
4. “范围请求” [RFC7233]
5. “缓存” [RFC7234]
6. “认证” [RFC7235]

这个 HTTP/1.1 规范废除了 RFC 2616 和 RFC 2145（关于 HTTP 版本）。该规范还更新了以前在 RFC 2817 中定义的使用 CONNECT 建立隧道的方法，并定义了在 RFC 2818 中非正式描述的 “https” URI 方案。

HTTP 是一个信息系统的通用接口协议。它旨在通过向客户提供一个独立于所提供的资源类型的统一接口，来隐藏服务实现的细节。同样，服务器也不需要知道每个客户的目的：一个 HTTP 请求可以被独立地考虑，而不是与特定类型的客户或预先确定的应用步骤序列相关联。其结果是一个可以在许多不同的环境中有效使用的协议，其实现可以随着时间的推移独立发展。

HTTP 也被设计为一种中继协议，用于转译与非 HTTP 报文系统的通信。HTTP 代理和网关可以提供对其他报文服务的访问，将其不同的协议转译成超文本格式，可以被客户以与 HTTP 服务相同的方式查看和操作。

这种灵活性的一个后果是，不能用接口后面发生的事情来定义协议。相反，我们只限于定义通信的语法、接收通信的意图以及接收方的预期行为。如果通信被孤立地考虑，那么成功的行动应该反映在对服务器提供的可观察界面的相应改变中。然而，由于多个客户可能平行行动，而且可能是交叉行动，我们不能要求这种变化在单个响应的范围之外可以观察到。

本文件描述了在 HTTP 中使用或提及的架构的基本组成，定义了 “http” 和 “https” URI 方案，描述了整体网络运作和连接管理，并定义了 HTTP 报文分帧和转发要求。我们的目标是定义所有独立于报文语义的 HTTP 报文处理所需的机制，从而为报文解析器和报文转发中继定义一套完整的要求。

## 1.1. 要求记号

本文档中的关键词 “必须”、“不得”、“需要”、“应当”、“不应当”、“应该”、“不应该”、“推荐”、“可以” 和 “可选” 应按照[RFC 2119]中的描述进行解释。

有关错误处理的符合性标准和注意事项在第 2.5 节中定义。

## 1.2. 语法记号

本规范使用 [RFC 5234] 的 Augmented Backus-Naur Form (ABNF) 计法，并在第 7 节中定义了一个列表扩展，允许使用'#'运算符（类似于'\*'运算符表示重复的方式）紧凑地定义逗号分隔的列表。附录 B 显示了收集的语法，其中所有的列表操作符都扩展为标准的 ABNF 符号。

以下核心规则通过参考包括在 [RFC 5234] 附录 B.1 中的定义。ALPHA（字母）、CR（回车）、CRLF（CR LF）、CTL（控制）、DIGIT（十进制 0-9）、DQUOTE（双引号）、HEXDIG（十六进制 0-9/A-F/a-f）、HTAB（水平制表符）、LF（换行）、OCTET（任何 8 位数据序列）、SP（空格）和 VCHAR（任何可见[USASCII]字符）。

按照惯例，ABNF 规则名称前缀为 “obs-”，表示由于历史原因出现的 “过时”语法规则。

# 2. 架构

HTTP 是为万维网(WWW)架构而创建的，并随着时间的推移不断发展，以支持全球超文本系统的可扩展性需求。该架构的大部分内容反映在用于定义 HTTP 的术语和语法产生式上。

## 2.1. 客户/服务器交换报文

HTTP 是一个无状态的请求/响应协议，通过可靠的传输层或会话层的 “连接”（第 6 节）交换报文（第 3 节）。一个 HTTP **“客户(client)”** 是一个程序，它建立了一个与服务器的连接，目的是发送一个或多个 HTTP 请求。HTTP **“服务器(server)”** 是一个接受连接的程序，以便通过发送 HTTP 响应来服务 HTTP 请求。

术语 “客户” 和 “服务器” 仅指这些程序在特定连接中所扮演的角色。同一个程序可能在某些连接上充当客户，而在其他连接上充当服务器。术语 **“用户代理(user agent)”** 是指发起请求的各种客户程序，包括（但不限于）浏览器、爬虫（基于网络的机器人）、命令行工具、定制化应用程序和移动应用程序。术语 **“源服务器(origin server)”** 指的是能够为特定目标资源发起权威响应的程序。术语 **“发送方(sender)”** 和 **“接收方(recipent)”** 分别指发送或接收特定报文的任何实现。

HTTP 依靠 **统一资源标识符(Uniform Resource Identifier, URI)** 标准[RFC 3986]来表示目标资源（第 5.1 节）和资源之间的关系。报文的传递格式类似于 Internet 邮件[RFC 5322]和多用途 Internet 邮件扩展（MIME）[RFC 2045] 所使用的格式（关于 HTTP 和 MIME 报文的区别，请参见[RFC 7231]的附录 A）。

大多数 HTTP 通信包括对由 URI 识别的某些资源的表示的检索请求（GET）。在最简单的情况下，这可能是通过用户代理（UA）和源服务器（O）之间的单一双向连接（==）完成的。

```
        请求 >>>
UA ======================================= O
                                <<< 响应
```

客户以请求报文的形式向服务器发送一个 HTTP 请求，以包括方法、URI 和协议版本的请求行开始（第 3.1.1 节），然后是包含请求修饰字段、客户报文和表示元数据的首部字段（第 3.2 节），一个空行表示首部的结束，最后是包含有效载荷的报文体（如果有的话，第 3.3 节）。

服务器通过发送一个或多个 HTTP 响应报文来响应客户的请求，每个响应报文以一个状态行开始，其中包括协议版本、成功或错误代码以及文本原因短语（第 3.1.2 节），后面可能是包含服务器报文、资源元数据和表示元数据的首部字段（第 3.2 节），一个空行表示首部的结束，最后是包含有效载荷的报文体（如果有的话，第 3.3 节）。

一个连接可能用于多个请求/响应交互，如第 6.3 节所定义。

下面的例子说明了 URI “http://www.example.com/hello.txt” 的 GET 请求（[RFC 7231]第 4.3.1 节）的典型报文交互。

客户请求：

```http
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

服务器响应：

```http
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My payload includes a trailing CRLF.
```

## 2.2. 实现多样性

在考虑 HTTP 的设计时，很容易落入一个陷阱，认为所有的用户代理都是通用的浏览器，所有的源服务器都是大型的公共网站。实际情况并非如此。常见的 HTTP 用户代理包括家用电器、音响、天平、固件更新脚本、命令行程序、移动应用程序以及各种形状和大小的通信设备。同样，常见的 HTTP 源服务器包括家庭自动化装置、可配置的网络部分、办公机器、自动机器人、新闻源、交通摄像首部、广告选择器和视频交付平台。

术语 “用户代理” 并不意味着在请求时有一个人类用户直接与软件代理进行互动。在许多情况下，用户代理被安装或配置为在后台运行，并保存其结果供以后检查（或只保存那些可能有趣或错误的结果的子集）。例如，爬虫通常被赋予一个起始 URI，并被配置为在作为超文本图抓取网络时遵循某些行为。

HTTP 的实现多样性意味着并非所有的用户代理都能向他们的用户提出交互式建议，或为安全或隐私问题提供足够的警告。在本规范要求向用户报告错误的少数情况下，这种报告只在错误控制台或日志文件中可以观察到是可以接受的。同样地，要求自动操作在进行之前由用户确认的要求可以通过预先的配置选择、运行时选项或简单地避免不安全的动作；如果用户已经做出了选择，确认并不意味着任何特定的用户界面或中断正常处理。

## 2.3. 中继

HTTP 允许使用中继，通过一连串的连接来满足请求。有三种常见的 HTTP 中继形式：代理、网关和隧道。在某些情况下，一个中继可能充当源服务器、代理、网关或隧道，根据每个请求的性质切换行为。

```
    >>>         >>>         >>>         >>>
UA =========== A =========== B =========== C =========== O
            <<<             <<<           <<<        <<<
```

上图显示了用户代理和源服务器之间的三个中继（A、B 和 C）。一个穿越整个链条的请求或响应报文将通过四个独立的连接。一些 HTTP 通信选项可能只适用于与最近的、非隧道邻接节点的连接，只适用于链的端点，或适用于沿链的所有连接。尽管图表是线性的，但每个参与者都可能参与多个同时进行的通信。例如，B 在处理 A 的请求的同时，可能正在接收来自 A 以外的许多客户的请求，和/或将请求转发给 C 以外的服务器。同样，后来的请求可能会通过不同的连接路径发送，通常是基于负载平衡的动态配置。

术语 **“上游(upstream)”** 和 **“下游(downstream)”** 用于描述与报文流有关的方向性要求：所有报文都从上游流向下游。术语 **“入站(inbound)”** 和 **“出站(outbound)”** 用于描述与请求路线有关的方向性要求。“入站” 是指朝向源服务器，“出站” 是指朝向用户代理。

**代理(proxy)** 是一个报文转发代理，由客户选择，通常通过本地配置规则，接收对某些类型的绝对 URI 的请求，并试图通过 HTTP 接口的转译来满足这些请求。一些转译是最小的，例如对 “http” URI 的代理请求，而其他请求可能需要转译成完全不同的应用级协议。为了安全、注释服务或共享缓存，代理通常被用来通过一个共同的中继来组合一个组织的 HTTP 请求。一些代理被设计成在转发时对选定的报文或有效载荷进行转换，如 5.7.2 节所述。

**网关(gateway)** （又称 “反向代理”）是一个中继，它作为出站连接的源服务器，它转译收到的请求并将其转发到另一个或多个服务器。网关经常被用来封装传统的或不被信任的报文服务，通过 “加速器” 缓存来提高服务器的性能，并实现 HTTP 服务在多台机器上的分区或负载平衡。

所有适用于源服务器的 HTTP 要求也适用于网关的出站通信。网关使用它所希望的任何协议与入站服务器进行通信，包括本规范范围之外的 HTTP 的私有扩展。然而，一个希望与第三方 HTTP 服务器互通的 HTTP-to-HTTP 网关应该符合网关入站连接的用户代理要求。

**隧道(tunnel)** 作为两个连接之间的无目的中继，不改变报文。一旦激活，隧道不被认为是 HTTP 通信的一方，尽管隧道可能是由一个 HTTP 请求发起的。当中继连接的两端都关闭时，隧道就不存在了。隧道被用来通过一个中继扩展一个虚拟连接，例如，当传输层安全（TLS，[RFC 5246]）被用来通过一个共享的防火墙代理建立保密通信。

上述中继的类别只考虑那些作为 HTTP 通信的参与者。也有一些中继可以在网络协议栈的较低层发挥作用，在报文发送方不知情或没有许可的情况下过滤或重定向 HTTP 流量。网络中继（在协议层面）与中继攻击没有区别，往往由于错误地违反了 HTTP 语义而引入安全缺陷或互操作性问题。

例如，“拦截代理”[RFC 3040]（通常也被称为 “透明代理” [RFC 1919]）与 HTTP 代理不同，因为它不是由客户选择的。相反，拦截代理过滤或重定向传出的 TCP 80 端口分组（偶尔也有其他普通端口流量）。拦截代理通常出现在公共网络接入点上，作为在允许使用非本地 Internet 服务之前执行账户订阅的一种手段，以及在企业防火墙内执行网络使用策略。

HTTP 被定义为一个无状态协议，这意味着每个请求报文都可以被独立地理解。许多实现都依赖于 HTTP 的无状态设计，以便重复使用代理连接或在多个服务器上动态地平衡请求。因此，服务器不能假定同一连接上的两个请求是来自同一个用户代理，除非该连接是安全的，并且是特定于该代理的。一些非标准的 HTTP 扩展（例如，[RFC 4559]）已经被认为违反了这一要求，导致了安全和互操作性问题。

## 2.4. 缓存

**缓存(cache)** 是过去响应报文的本地存储，是控制其报文存储、检索和删除的子系统。缓存存储可缓存响应，以减少未来同等请求的响应时间和网络带宽消耗。任何客户或服务器都可以使用缓存，尽管服务器在作为隧道时不能使用缓存。

缓存的作用是，如果链上的一个参与者有一个适用于该请求的缓存响应，那么请求/响应链就会缩短。下面说明了如果 B 拥有 O（通过 C）对一个没有被 UA 或 A 缓存的请求的早期响应的缓存副本，那么产生的链:

```
    >>>         >>>         >>>         >>>
UA =========== A =========== B - - - - - - C - - - - - - O
            <<<             <<<           <<<        <<<
```

如果允许缓存存储响应报文的副本以用于回答后续请求，那么响应就是 “可缓存的”。即使一个响应是可缓存的，也可能有客户或源服务器对该缓存响应何时可用于特定请求的额外限制。HTTP 对缓存行为和可缓存响应的要求在[RFC 7234]的第 2 节中定义。

在万维网和大型组织内部部署了各种各样的架构和缓存配置。这些包括国家层次的代理缓存以节省跨洋带宽，广播或多播缓存条目的协作系统，用于离线或高延迟环境的预取缓存条目的档案，等等。

## 2.5. 符合性和错误处理

本规范根据 HTTP 通信中的参与者的角色来确定符合性标准。因此，HTTP 要求被置于发送方、接收方、客户、服务器、用户代理、中继、源服务器、代理、网关或缓存上，这取决于什么行为被要求所限制。额外的（社会）要求被放在实现、资源所有者和协议元素注册上，当它们适用于单个通信的范围之外。

动词 “生成” 被用来代替 “发送”，当需求区分了创建协议元素和仅仅将收到的元素转发给下游时。

如果一个实现符合与它在 HTTP 中的角色相关的所有要求，那么它就被认为是符合的。

符合性包括协议元素的语法和语义。发送方 **不得** 生成传达错误含义的协议元素，而该发送方知道这一点。发送方 **不得** 产生不符合相应 ABNF 规则所定义的语法的协议元素。在一个给定的报文中，发送方 **不得** 生成只允许由其他角色的参与者（即发送方对该报文不具有的角色）生成的协议元素或语法替代。

当收到的协议元素被解析时，接收方 **必须** 能够解析适用于接收方角色的任何合理长度的值，并且与相应的 ABNF 规则所定义的语法相匹配。然而，请注意，一些收到的协议元素可能不会被解析。例如，转发报文的中继可能会将首部字段解析为通用的字段名和字段值成分，但随后转发首部字段，而不进一步解析字段值内部。

HTTP 对它的许多协议元素没有具体的长度限制，因为可能适合的长度会有很大的不同，取决于部署环境和实现的目的。因此，发送方和接收方之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外，在过去 20 年的 HTTP 使用过程中，人们普遍认为某些协议元素的合理长度已经发生了变化，预计未来还会继续变化。

至少，接收方 **必须** 能够解析和处理协议元素的长度，至少与它在其他报文中为这些相同的协议元素产生的值一样长。例如，一个发布非常长的 URI 引用到它自己的资源的初始服务器需要能够在收到请求目标时解析和处理这些相同的引用。

接收方 **必须** 根据本规范为其定义的语义（包括本规范的扩展）来解释收到的协议元素，除非接收方（通过经验或配置）确定发送方不正确地实现这些语义所暗示的内容。例如，如果对 User-Agent 首部字段的检查表明一个特定的实现版本在收到某些内容编码时是失败的，那么一个源服务器可能会忽略收到的 Accept-Encoding 首部字段的内容。

除非另有说明，接收方 **可以** 尝试从一个无效的结构中恢复一个可用的协议元素。HTTP 没有定义具体的错误处理机制，除非它们对安全有直接影响，因为协议的不同应用需要不同的错误处理策略。例如，网络浏览器可能希望透明地从位置首部字段没有按照 ABNF 解析的响应中恢复，而系统控制客户可能认为任何形式的错误恢复都是危险的。

## 2.6. 协议版本

HTTP 使用“<主要版本号>.<次要版本号>”的编号方案来表示协议的版本。本规范定义了 "1.1" 版本。协议版本作为一个整体表明发送方符合该版本对应的 HTTP 规范中规定的一系列要求。

HTTP 报文的版本由报文第一行的 HTTP-version 字段表示。HTTP-version 是区分大小写的。

```
HTTP-version = HTTP-name "/" DIGIT "." DIGIT
HTTP-name = %x48.54.54.50 ; "HTTP", case-sensitive
```

HTTP 版本号由两位小数组成，以“.”（句号或小数点）分开。第一个数字（“主要版本号”）表示 HTTP 报文传输语法，而第二个数字（“次要版本号”）表示该主要版本中最高的次要版本，发送方符合并能够理解该版本，以便将来进行通信。次要版本通告发送方的通信能力，即使发送方只使用协议的向后兼容的子集，从而让接收方知道，更高级的功能可以在响应（由服务器）或未来的请求（由客户）中使用。

当 HTTP/1.1 报文被发送到 HTTP/1.0 接收方[RFC 1945]或版本未知的接收方时，HTTP/1.1 报文的构造是，如果所有较新的功能被忽略，它可以被解释为一个有效的 HTTP/1.0 报文。本规范对一些新特性提出了接收方版本的要求，这样符合要求的发送方将只使用兼容的特性，直到它通过配置或收到的报文确定接收方支持 HTTP/1.1。

一个首部字段的解释在同一主要 HTTP 版本的不同次要版本之间不会改变，尽管接收方在没有这样一个字段时的默认行为可能会改变。除非另有规定，在 HTTP/1.1 中定义的首部字段是为 HTTP/1.x 的所有版本定义的。特别是，所有 HTTP/1.x 的实现都应该实现 Host 和 Connection 首部字段，不管它们是否通告与 HTTP/1.1 一致。

如果新的首部字段定义的语义允许它们被不认识它们的接收方安全地忽略，那么可以在不改变协议版本的情况下引入这些字段。3.2.1 节中讨论了首部字段的可扩展性。

处理 HTTP 报文的中继（即除了作为隧道的中继以外的所有中继）**必须** 在转发的报文中发送自己的 HTTP 版本。换句话说，他们不允许无目的地转发 HTTP 报文的第一行，而不确保该报文中的协议版本与该中继在接收和发送报文时符合的版本一致。在没有重写 HTTP-版本的情况下转发 HTTP 报文，当下游接收方使用报文发送方的版本来确定以后与该发送方的通信可以安全使用哪些功能时，可能会导致通信错误。

客户 **应该** 发送一个与客户符合的最高版本相等的请求版本，并且其主要版本号不高于服务器所支持的最高版本，如果这是已知的。客户 **不得** 发送它不符合的版本。

如果知道服务器不正确地实现了 HTTP 规范，客户 **可以** 发送一个较低的请求版本，但只有在客户尝试了至少一个正常的请求并从响应状态码或首部字段（例如，Server）确定服务器不正确地处理较高的请求版本之后。

服务器 **应该** 发送一个与服务器符合的最高版本相等的响应版本，并且其主要版本号不高于请求中收到的版本。服务器 **不应该** 发送它不符合的版本。如果服务器出于任何原因希望拒绝为客户的主要协议版本提供服务，它 **可以** 发送一个 505(HTTP Version Not Supporte)响应。

如果已知或怀疑客户不正确地实现了 HTTP 规范，并且没有能力正确地处理后来的版本响应，例如，当客户未能正确地解析版本号时，或者当已知中继盲目地转发 HTTP-版本时，即使它不符合给定的协议的次要版本，服务器 **可以** 对请求发送 HTTP/1.0 响应。这种协议降级不应该被执行，除非由特定的客户属性触发，例如当一个或多个请求首部字段（如 User-Agent）与已知有错误的客户发送的值唯一匹配时。

HTTP 版本设计的意图是，只有在引入不兼容的报文语法时，才会增加主版本号，而只有在对协议的修改具有增加报文语义或暗示发送方的额外能力的效果时，才会增加次版本号。然而，在[RFC 2068]和[RFC 2616]之间引入的变化中，次要版本没有被递增，这次修订特别避免了对协议的任何此类变化。

当收到一个 HTTP 报文，其主要版本号是接收方实现的，但其次要版本号比接收方实现的要高，接收方应将该报文作为接收方符合的该主要版本中的最高次要版本来处理。接收方可以认为，当发送至尚未表示支持更高版本的接收方时，具有更高次要版本的报文是充分向后兼容的，可以被同一主要版本的任何实现安全地处理。

## 2.7. 统一资源标识符(URI)

**统一资源标识符(Uniform Resource Identifiers, URI)** [RFC 3986]在整个 HTTP 中被用作识别资源的方法（[RFC 7231]第 2 节）。**URI 引用(URI references)** 被用来定位请求，指示重定向，并定义关系。

“URI-reference”、“absolute-URI”、“relative-part”、“scheme”、“authority”、“port”、“host”、“path-abempty”、“segment”、“query” 和 “fragment” 的定义来自 URI 通用语法。一个 “绝对路径(absolute-URI)” 规则被定义为可以包含一个非空的路径部分的协议元素。(这个规则与 RFC 3986 的 path-abempty 规则略有不同，后者允许在引用中使用空路径，而 path-absolute 规则则不允许以 “//” 开首部的路径）。) “部分 URI("partial-URI)” 规则是为可以包含相对 URI 但不包含 fragment 部分的协议元素而定义的。

```
URI-reference = <URI-reference, see [RFC3986], Section 4.1>
absolute-URI = <absolute-URI, see [RFC3986], Section 4.3>
relative-part = <relative-part, see [RFC3986], Section 4.2>
scheme = <scheme, see [RFC3986], Section 3.1>
authority = <authority, see [RFC3986], Section 3.2>
uri-host = <host, see [RFC3986], Section 3.2.2>
port = <port, see [RFC3986], Section 3.2.3>
path-abempty = <path-abempty, see [RFC3986], Section 3.3>
segment = <segment, see [RFC3986], Section 3.3>
query = <query, see [RFC3986], Section 3.4>
fragment = <fragment, see [RFC3986], Section 3.5>

absolute-path = 1*( "/" segment )
partial-URI = relative-part [ "?" query ]
```

HTTP 中每个允许 URI 引用的协议元素将在其 ABNF 生产中指出该元素是否允许任何形式的引用（URI-reference），只允许绝对形式的 URI（absolute-URI），只允许路径和可选查询部分，或上述的一些组合。除非另有说明，URI 引用是相对于有效请求 URI 解析的（第 5.5 节）。

### 2.7.1. http URI 方案

在此定义 “http” URI 方案，目的是根据其与潜在的 HTTP 源服务器在特定端口上监听 TCP（[RFC 0793]）连接所管理的层次化命名空间的关联来生成标识符。

```
http-URI = "http:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```

“http” URI 的源服务器是由权威(authority)确定的，其中包括一个主机标识符和可选的 TCP 端口（[RFC 3986]，第 3.2.2 节）。分层路径(path-abempty)部分和可选的查询(query)部分作为该源服务器命名空间中潜在目标资源的标识符。如[RFC 3986]第 3.5 节所定义，可选片段(fragment)部分允许间接识别二级资源，与 URI 方案无关。

发送方 **不得** 生成带有空主机标识符的 “http” URI。处理这种 URI 引用的接收方 **必须** 拒绝它，因为它是无效的。

如果主机标识符被提供为一个 IP 地址，那么源服务器就是该 IP 地址上指定的 TCP 端口的监听器（如果有的话）。如果主机是一个注册的域名，注册的域名是一个间接的标识符，用于域名解析服务，如 DNS，为该源服务器找到一个地址。如果端口子部分是空的或没有给出，TCP 端口默认为 80（为 WWW 服务保留的端口）。

请注意，一个具有特定权威部分的 URI 的存在并不意味着总是有一个 HTTP 服务器在监听该主机和端口的连接。任何人都可以伪造一个 URI。权威部分所决定的是谁有权对针对所识别资源的请求作出权威性的回应。注册域名和 IP 地址的授权性质创建了一个联合命名空间，基于对指定主机和端口的控制，无论是否有 HTTP 服务器存在。与建立授权有关的安全考虑见第 9.1 节。

当 “http” URI 被用于要求访问指定资源的背景中时，客户 **可以** 通过将主机解析为一个 IP 地址，在指定的端口上与该地址建立一个 TCP 连接，并向服务器发送一个包含 URI 识别数据（第 5 节）的 HTTP 请求报文（第 3 节）来尝试访问。如果服务器用非间断的 HTTP 响应报文回应该请求，如[RFC 7231]第 6 节所述，那么该响应被认为是对客户请求的权威性回答。

尽管 HTTP 独立于传输协议，但 “http” 方案是基于 TCP 的服务所特有的，因为名称委托过程依赖于 TCP 来建立权威。基于其他底层连接协议的 HTTP 服务大概会使用不同的 URI 方案来识别，就像 “https” 方案（下文）用于需要端到端安全连接的资源。其他协议也可能被用来提供对 “http” 标识的资源的访问--只有权威接口是特定于 TCP 的。

权威的 URI 通用语法还包括一个废弃的 userinfo 子部分（[RFC 3986]，第 3.2.1 节），用于在 URI 中包括用户认证报文。一些实现将 userinfo 部分用于认证报文的内部配置，例如在命令调用选项、配置文件或书签列表中，尽管这种用法可能会暴露用户标识符或密码。当 “http” URI 引用作为请求目标或首部字段值在报文中生成时，发送方不得生成 userinfo 子部分（及其"@"分隔符）。在使用从不可信任的来源收到的 “http” URI 引用之前，接收方应该解析用户报文，并将其存在视为一个错误；它很可能被用来掩盖权限，以进行网络钓鱼攻击。

### 2.7.2. https URI 方案

在此定义 “https” URI 方案，目的是根据标识符与潜在的 HTTP 源服务器为 TLS 安全连接监听给定的 TCP 端口所管辖的分层命名空间的关联来创建标识符（[RFC 5246]）。

上面列出的对 “http” 方案的所有要求也是对 “https” 方案的要求，但如果端口子部分为空或未给出，则 TCP 端口 443 是默认的，而且用户代理必须确保在发送第一个 HTTP 请求之前，通过使用强大的加密技术，端到端确保其与源服务器的连接是安全的。

```
https-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment ]
```

请注意，“https” URI 方案依赖于 TLS 和 TCP 来建立权威。通过 “https” 方案提供的资源与 “http” 方案没有共同的身份，即使它们的资源标识符显示相同的授权（同一主机监听同一 TCP 端口）。它们是不同的命名空间，被认为是不同的源服务器。然而，被定义为适用于整个主机域的 HTTP 的扩展，如 Cookie 协议[RFC 6265]，可以允许一个服务设置的报文影响与匹配的主机域组中的其他服务的通信。

[RFC 2818]中定义了对 “https” 标识资源的权威性访问过程。

### 2.7.3. http 和 https URI 的标准化和比较

由于 “http” 和 “https” 方案符合 URI 的通用语法，这种 URI 被标准化，并根据[RFC 3986]第 6 节中定义的算法进行比较，使用上述每种方案的默认值。

如果端口等于某个方案的默认端口，正常形式是省略端口子部分。当不是以绝对形式作为 OPTIONS 请求的请求目标时，空的路径部分等同于“/”的绝对路径，所以正常的形式是提供“/”的路径来代替。方案和主机是不区分大小写的，通常以小写提供；所有其他部分以区分大小写的方式进行比较。除 “保留” 集的字符外，其他字符相当于其百分比编码的字节：正常形式是不对其进行编码（见[RFC 3986]第 2.1 和 2.2 节）。

例如，以下的 3 个 URI 是相等的：

```
http://example.com:80/˜smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html
```

# 3. 报文格式

所有的 HTTP/1.1 报文都由一个起始行组成，后面是一串格式类似于 Internet 报文格式[RFC 5322]的字节：零个或多个首部字段（统称为 “首部” 或 “首部区域”），一个表示首部区域结束的空行，以及一个可选的报文体。

```
HTTP-message = start-line
               *( header-field CRLF )
               CRLF
               [ message-body ]
```

解析 HTTP 报文的正常程序是将起始行读入一个结构，按字段名将每个首部字段读入一个哈希表，直到空行为止，然后使用解析后的数据来确定是否期望有一个报文体。如果显示有报文体，那么它将作为一个流被读取，直到读取到与报文体长度相等的字节或连接被关闭。

接收方 **必须** 将 HTTP 报文解析为一个字节的序列，其编码是 US-ASCII[USASCII]的超集。将 HTTP 报文解析为 Unicode 字符流，而不考虑具体的编码。由于字符串处理库处理包含字节 LF(%x0A)的无效多字节字符序列的方式不同，因此会产生安全漏洞。基于字符串的解析器只能在协议元素从报文中提取后安全地使用，例如在报文解析划定各个字段后，在首部字段-值中使用。

一个 HTTP 报文可以被解析为一个流，用于增量处理或转发到下游。然而，接收方不能依赖部分报文的递增交付，因为有些实现会为了网络效率、安全检查或有效载荷的转换而缓存或延迟报文的转发。

发送方 **不得** 在起始行和第一个首部字段之间发送空白。接收方如果收到在起始行和第一个首部字段之间的空白，**必须** 拒绝该报文为无效，或者在不进一步处理的情况下消耗每一个以空白为前导的行（即，忽略整个行，以及任何以空白为前导的后续行，直到收到一个正确形成的首部字段或首部区域被终止）。

在请求中出现这样的空白可能是试图欺骗服务器忽略该字段或将其后面的行作为一个新的请求来处理，如果请求链中的其他实现对同一报文有不同的解释，这两种情况都可能导致安全漏洞。同样，在响应中出现这样的空白可能会被一些客户忽略或导致其他客户停止解析。

## 3.1. 起始行

一条 HTTP 报文可以是客户到服务器的请求，也可以是服务器到客户的响应。从语法上讲，这两种类型的报文只在起始行上有区别，起始行可以是 **请求行**（用于请求），也可以是 **状态行**（用于响应），以及确定报文体长度的算法（第 3.3 节）。

在理论上，客户可以接收请求，服务器可以接收响应，通过不同的起始行格式来区分它们，但是，在实践中，服务器被实现为只期望一个请求（响应被解释为一个未知或无效的请求方法），而客户被实现为只期望一个响应。

```
start-line = request-line / status-line
```

### 3.1.1. 请求行

一个请求行以一个方法(method)标记开始，然后是一个空格（SP），请求目标(request-target)，另一个空格（SP），协议版本(HTTP-version)，最后以 CRLF 结束。

```
request-line = method SP request-target SP HTTP-version CRLF
```

方法标记表示要对目标资源执行的请求方法。请求方法是区分大小写的。

```
method = token
```

本规范所定义的请求方法可以在[RFC 7231]的第 4 节中找到，同时还有关于 HTTP 方法注册的报文和定义新方法的注意事项。

**请求目标(request-target)** 标识了应用该请求的目标资源，如第 5.3 节所定义。

接收方通常通过分割空白处来解析请求行的组成部分（见第 3.5 节），因为三个组成部分中不允许有空白。不幸的是，一些用户代理未能正确编码或排除超文本引用中的空白，导致这些不允许的字符被发送到请求目标中。

无效请求行的接收方 **应该** 以 400(Bad Request) 错误或 301(Moved Permanently)重定向来回应，并对请求目标进行正确编码。接收方 **不应该** 试图自动更正，然后在没有重定向的情况下处理请求，因为无效的请求行可能是故意制作的，以绕过请求链上的安全过滤器。

如第 2.5 节所述，HTTP 没有对请求行的长度进行预定义的限制。一个服务器如果收到一个比它所实现的任何方法都长的方法，**应该** 用 501(Not Implemented)状态码来响应。如果服务器收到的请求目标长于它希望解析的任何 URI，则 **必须** 以 414(URI Too Long)状态码进行响应（参见第 6.5.12 节[RFC 7231]）。

在实践中会发现对请求行长度的各种特别限制。**推荐** 所有 HTTP 发送方和接收方至少支持 8000 个字节的请求行长度。

### 3.1.2. 状态行

响应报文的第一行是状态行，由协议版本(HTTP-version)、空格（SP）、状态码(status-code)、另一个空格、描述状态码的可能为空的原因短语(reason-phrase)组成，并以 CRLF 结束。

```
status-line = HTTP-version SP status-code SP reason-phrase CRLF
```

status-code 部分是一个 3 位数的整数代码，描述了服务器试图理解和满足客户的相应请求的结果。响应报文的其余部分将根据为该状态码定义的语义来解释。关于状态码的语义，包括状态码的类别（由第一个数字表示）、本规范定义的状态码、定义新状态码的注意事项以及 IANA 注册表，见[RFC 7231]的第 6 节。

```
status-code = 3DIGIT
```

原因短语部分存在的唯一目的是提供与数字状态码相关的文本描述，这主要是出于对早期 Internet 应用协议的尊重，这些协议更经常地用于交互式文本客户。客户 **应该** 忽略原因短语的内容。

```
reason-phrase = *( HTAB / SP / VCHAR / obs-text )
```

## 3.2. 首部字段

每个首部字段由一个不区分大小写的字段名组成，后面是冒号（":"）、可选的前导空白、字段值和可选的后导空字段名标记将相应的字段值标记为具有该首部字段所定义的语义。例如，在[RFC 7231]第 7.1.1.2 节中，Date 首部字段被定义为包含它所出现的报文的发起时间戳。

```
header-field = field-name ":" OWS field-value OWS

field-name = token
field-value = *( field-content / obs-fold )
field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
field-vchar = VCHAR / obs-text

obs-fold = CRLF 1*( SP / HTAB )
           ; obsolete line folding
           ; see Section 3.2.4
```

字段名标记将相应的字段值标记为具有该首部字段所定义的语义。例如，在[RFC 7231]第 7.1.1.2 节中，Date 首部字段被定义为包含它所出现的报文的发起时间戳。

### 3.2.1. 字段扩展性

首部字段是完全可扩展的：对引入新的字段名没有限制，每个字段大概都定义了新的语义，也没有限制在一个给定报文中使用的首部字段的数量。现有的字段在本规范的每个部分和本文档集以外的许多其他规范中都有定义。

新的首部字段可以被定义，当它们被接收方理解时，它们可以覆盖或加强对先前定义的首部字段的解释，定义请求评估的前提条件，或完善响应的含义。

代理 **必须** 转发未识别的首部字段，除非字段名被列在连接首部字段中（第 6.1 节），或者代理被特别配置为阻止或以其他方式转换这些字段。其他接收方 **应该** 忽略未被识别的首部字段。这些要求允许 HTTP 的功能得到增强，而不需要事先更新已部署的中继。

所有定义的首部字段都应该在 IANA 的 "报文首部" 注册表中注册，如[RFC 7231]第 8.3 节中所述。

### 3.2.2. 字段顺序

接收具有不同字段名的首部字段的顺序并不重要。然而，好的做法是先发送包含控制数据的首部字段，如请求中的 Host 和响应中的 Date，这样实现就可以尽早决定何时不处理一个报文。在收到整个请求首部区域之前，服务器 **不得** 将请求应用于目标资源，因为后来的首部字段可能包括条件、认证凭证或故意误导的重复首部字段，这将影响请求处理。

发送方 **不得** 在一条报文中生成具有相同字段名的多个首部字段，除非该首部字段的整个字段值被定义为逗号分隔的列表[即#(value)]，或者该首部字段是众所周知的例外（如下所述）。

接收方 **可以** 将具有相同字段名的多个首部字段合并为一个 “字段名: 字段值” 对，而不改变报文的语义，方法是将每个后续字段值按顺序附加到合并的字段值上，用逗号分隔。因此，具有相同字段名的首部字段的接收顺序对组合字段值的解释很重要；代理在转发报文时 **不得** 改变这些字段值的顺序。

注意：在实践中，“Set-Cookie” 首部字段（[RFC 6265]）经常在响应报文中出现多次，并且不使用列表语法，违反了上述关于多个同名首部字段的要求。由于它不能被合并成一个字段值，接收方在处理首部字段时应该把 “Set-Cookie” 作为一种特殊情况来处理。(详见[Kri 2001]的附录 A.2.3）。)

### 3.2.3. 空白

本规范使用三种规则来表示线性空白的使用。OWS（可选空白）、RWS（必需空白）和 BWS（“坏”空白）。

OWS 规则用于可能出现零或更多线性空白的字节。对于为了提高可读性而倾向于选择空白的协议元素，发送方 **应该** 将可选的空白生成为单个 SP；否则，发送方 **不应该** 生成可选的空白，除非在就地报文过滤过程中需要清除无效的或不需要的协议元素。

当至少需要一个线性空白的字节来分隔字段标记时，就会使用 RWS 规则。发送方 **应该** 将 RWS 生成为单个 SP。

BWS 规则用于语法仅出于历史原因允许可选的空白的情况。发送方 **不得** 在报文中生成 BWS。接收方 **必须** 在解释协议元素之前解析这种不良的空白并将其删除。

```
OWS = *( SP / HTAB )
      ; optional whitespace
RWS = 1*( SP / HTAB )
      ; required whitespace
BWS = OWS
      ; "bad" whitespace
```

### 3.2.4. 字段解析

报文是用一种通用的算法来解析的，与各个首部字段的名称无关。一个给定的字段值内的内容直到报文解释的后期阶段才会被解析（通常是在报文的整个首部区域被处理之后）。因此，本规范不使用 ABNF 规则来定义每个 “字段名: 字段值” 对，就像以前的版本那样。相反，本规范使用根据每个注册的字段名命名的 ABNF 规则，其中该规则定义了该字段对应的字段值的有效语法（即，在字段-值被通用字段分析器从首部区域提取后）。

首部字段名和冒号之间不允许有空白。在过去，对这种空白处理的不同导致了请求路由和响应处理中的安全漏洞。服务器 **必须** 拒绝任何收到的、在首部字段名和冒号之间含有空格的请求报文，其响应代码为 400(Bad Request)。代理 **必须** 在向下游转发报文之前从响应报文中删除任何此类空白。

字段值前面和/或后面可能有可选的空白(OWS)；为了使人类的可读性一致，字段值前面最好有一个 SP。字段值不包括任何前面或后面的空白。在字段值的第一个非空白八位字节之前或在字段值的最后一个非空白八位字节之后出现的 OWS 应该被解析器在从首部字段中提取字段值时排除。

历史上，HTTP 首部的字段值可以通过在每一个额外的行前至少有一个空格或水平制表符（obs-fold）来扩展到多行。除了在 message/http 媒体类型中（第 8.3.1 节），本规范废除了这种折行。发送方 **不得** 生成包括折行的报文（即有任何包含与 obs-fold 规则相匹配的字段值），除非该报文打算在报文/http 媒体类型中打包。

在不在报文/http 容器内的请求报文中收到折行的服务器 **必须** 通过发送 400(Bad Request)来拒绝该报文，最好是用说明来解释折行是不可接受的，或者在解释字段值或将报文转发到下游之前用一个或多个 SP 字节来替换每个收到的折行。

代理或网关如果在不在报文/http 容器内的响应报文中收到废弃的折行，**必须** 丢弃该报文并以 502(Bad Gateway)响应代替它，最好带有解释收到不可接受的折行的表示，或者在解释字段值或向下游转发报文之前用一个或多个 SP 八位字节代替每个收到的废弃的折行。

用户代理如果在不在报文/http 容器内的响应报文中收到 obs-fold，那么在解释字段值之前，**必须** 用一个或多个 SP 字节替换每个收到的 obs-fold。

历史上，HTTP 允许字段内容采用 ISO-8859-1 字符集[ISO-8859-1]，只通过使用[RFC 2047]编码来支持其他字符集。在实践中，大多数 HTTP 首部字段值只使用 US-ASCII 字符集[USASCII]的一个子集。新定义的首部字段 **应该** 将其字段值限制在 US-ASCII 字节。接收方 **应该** 把字段内容（obs-text）中的其他八位字节视为不透明数据。

### 3.2.5. 字段限制

如第 2.5 节所述，HTTP 没有对每个首部字段的长度或首部区域的整体长度做出预定的限制。在实践中，对单个首部字段的长度有各种特别的限制，通常取决于具体的首部字段语义。

一个服务器如果收到的请求首部字段或字段集超过它希望处理的长度，**必须** 以适当的 4xx(Client Error)状态码来响应。忽略这些首部字段会增加服务器对请求偷渡攻击的脆弱性（第 9.5 节）。

如果字段的语义是可以安全地忽略掉被丢弃的值而不改变报文分帧或响应语义，那么客户 **可以** 丢弃或截断收到的大于客户希望处理的首部字段。

### 3.2.6. 字段值部分

大多数 HTTP 首部字段的值都是使用常见的语法部分（token、quoted-string 和 comment）来定义的，并以空格或特定的定界字符分隔。定界符是从标记中不允许的 US-ASCII 视觉字符集中选择的（DQUOTE 和"(),/:;<=>?@[\]{}"）。

```
token = 1*tchar

tchar = "!" / "#" / "$" / "%" / "&" / "’" / "*"
        / "+" / "-" / "." / "^" / "_" / "‘" / "|" / "˜"
        / DIGIT / ALPHA
        ; any VCHAR, except delimiters
```

如果一个文本字符串使用双引号引出，则被解析为一个单值。

```
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qdtext = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
obs-text = %x80-FF
```

注释可以包含在一些 HTTP 首部字段中，方法是用圆括号包围注释文本。注释只允许出现在包含 “注释” 的字段中，作为其字段值定义的一部分。

```
comment = "(" *( ctext / quoted-pair / comment ) ")"
ctext = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

反斜线字节("/")可以作为一个单字节的引号机制在引号字符串和注释结构中使用。处理引号字符串的值的接收方 **必须** 处理引号对，就像它被反斜杠后面的字节取代一样。

```
quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
```

发送方 **不应该** 在一个带引号的字符串中产生一个引号对，除非在必要时引用 DQUOTE 和该字符串中出现的反斜杠字节。发送方 **不应该** 在注释中产生一个带引号的对，除非在必要时引用括号["(" 和 ")"]和该注释中出现的反斜杠字节。

## 3.3. 报文体

HTTP 报文的报文体（如果有的话）被用来承载该请求或响应的有效载荷。报文体与有效载荷是相同的，除非应用了传输编码，如第 3.3.1 节中所述。

```
message-body = *OCTET
```

对于请求和响应来说，报文体何时被允许出现在报文中的规则不同。

请求中报文体的存在是由 Content-Length 或 Transfer-Encoding 首部字段来表示的。请求报文分帧与方法语义无关，即使该方法没有定义报文体的任何用途。

响应中报文体的存在取决于它所响应的请求方法和响应状态码（第 3.1.2 节）。对 HEAD 请求方法（[RFC 7231]第 4.3.2 节）的响应从不包括报文体，因为相关的响应首部字段（例如 Transfer-Encoding、Content-Length 等），如果存在的话，只表示如果请求方法是 GET（[RFC 7231]第 4.3.1 节），它们的值会是什么。对 CONNECT 请求方法（[RFC 7231]第 4.3.6 节）的 2xx(Successful)响应切换到隧道模式，而不是有一个报文体。所有 1xx(Informational)、204(No Content)和 304(Not Modified)响应都不包括报文体。所有其他响应都包括一个报文体，尽管该报文体可能是零长度。

### 3.3.1. Transfer-Encoding

Transfer-Encoding 首部字段列出了与已经（或将要）应用于有效载荷的传输编码序列相对应的传输编码名称，以形成报文体。传输编码的定义见第 4 节。

```
Transfer-Encoding = 1#transfer-coding
```

Transfer-Encoding 类似于 MIME 的 Content-Transfer-Encoding 字段，它被设计为在 7 位传输服务上实现二进制数据的安全传输（[RFC 2045]，第 6 节）。然而，安全传输对于一个 8 位的干净传输协议来说有不同的重点。在 HTTP 的情况下，Transfer-Encoding 主要是为了准确地划分动态生成的有效载荷，并将仅用于传输效率或安全的有效载荷编码与作为所选资源特征的编码区分开。

接收方 **必须** 能够解析分块传输编码（第 4.1 节），因为在事先不知道有效载荷大小的情况下，它在分帧报文方面起着关键作用。发送方 **不得** 对一个报文体应用分块一次以上（即不允许对已经分块的报文进行分块）。如果除 chunked 以外的任何传输编码被应用于请求有效载荷，发送方 **必须** 应用 chunked 作为最后的传输编码，以确保报文被正确地分帧。如果除 chunked 以外的任何传输编码被应用于响应有效载荷，发送方 **必须** 应用 chunked 作为最终传输编码或通过关闭连接来终止报文。

例如：

```
Transfer-Encoding: gzip, chunked
```

表示有效载荷已经使用 gzip 编码进行了压缩，然后在形成报文体时使用 chunked 编码进行分块。

与 Content-Encoding（[RFC 7231]第 3.1.2.1 节）不同，Transfer-Encoding 是报文的一个属性，而不是表示方法，而且沿着请求/响应链的任何接收方都 **可以** 对收到的传输编码进行解码，或者对报文体应用额外的传输编码，前提是对 Transfer-Encoding 字段值做出相应的改变。关于编码参数的其他报文可以由本规范没有定义的其他首部字段提供。

Transfer-Encoding **可以** 在对 HEAD 请求的响应中或对 GET 请求的 304(Not Modified)响应（[RFC 7232]第 4.1 节）中发送，这两个请求都不包括报文体，以表明如果该请求是无条件的 GET，源服务器将对报文体应用传输编码。然而，这种指示是不需要的，因为响应链上的任何接收方（包括源服务器）都可以在不需要传输编码时删除它们。

服务器 **不得** 在任何状态码为 1xx(Informational)或 204(No Content)的响应中发送传输编码首部字段。服务器 **不得** 在对 CONNECT 请求的任何 2xx(Successful)响应中发送 Transfer-Encoding 首部字段（[RFC 7231]的 4.3.6 节）。

Transfer-Encoding 是在 HTTP/1.1 中添加的。一般认为，只支持 HTTP/1.0 的实现将不理解如何处理传输编码的有效载荷。除非客户知道服务器会处理 HTTP/1.1（或更高版本）的请求，否则客户 **不得** 发送包含 Transfer-Encoding 的请求；这种通告可能是以特定的用户配置的形式，或者通过记住先前收到的响应的版本。除非相应的请求表明是 HTTP/1.1（或更高版本），否则服务器 **不得** 发送包含 Transfer-Encoding 的响应。

一个服务器如果收到一个带有它不理解的传输编码的请求报文，**应该** 以 501(Not Implemented)来响应。

### 3.3.2. Content-Length

当报文没有 Transfer-Encoding 首部字段时，Content-Length 首部字段可以为潜在的有效载荷提供预期的大小，作为一个十进制的字节数。对于包括有效载荷的报文，Content-Length 字段值提供了确定主体（和报文）结束位置所需的分帧报文。对于不包括有效载荷的报文，Content-Length 表示所选表示的大小（[RFC 7231]的第 3 节）。

```
Content-Length = 1*DIGIT
```

例如：

```
Content-Length: 3495
```

发送方 **不得** 在任何包含 Transfer-Encoding 首部字段的报文中发送 Content-Length 首部字段。

当没有发送 Transfer-Encoding 并且请求方法定义了所包含的有效载荷的含义时，用户代理 **应该** 在请求报文中发送 Content-Length。例如，通常在 POST 请求中发送 Content-Length 首部字段，即使其值为 0（表示一个空的有效载荷）。当请求报文不包含有效载荷，并且方法语义没有预料到有这样一个报文体时，用户代理 **不应该** 发送 Content-Length 首部字段。

服务器 **可以** 在对 HEAD 请求的响应中发送 Content-Length 首部字段（[RFC 7231]的第 4.3.2 节）；服务器 **不得** 在这种响应中发送 Content-Length，除非它的字段值等于如果同一请求使用 GET 方法时在响应的有效载荷中发送的十进制数。

服务器 **可以** 在对有条件的 GET 请求（[RFC 7232]第 4.1 节）的 304(Not Modified)响应中发送 Content-Length 首部字段；服务器 **不得** 在这种响应中发送 Content-Length，除非其字段值等于对同一请求的 200(OK)响应的有效载荷中所发送的十进制数。

服务器 **不得** 在任何状态码为 1xx(Informational)或 204(No Content)的响应中发送 Content-Length 首部字段。服务器 **不得** 在对 CONNECT 请求的任何 2xx(Successful)响应中发送 Content-Length 首部字段（[RFC 7231]的 4.3.6 节）。

除了上面定义的情况外，在没有 Transfer-Encoding 的情况下，当有效载荷出现时，源服务器 **应该** 发送一个 Content-Length 首部字段。因为在发送完整的首部区域之前，有效载荷的大小是已知的。这将允许下游接收方测量传输进度，知道什么时候收到的报文是完整的，并有可能为其他请求重新使用连接。

任何大于或等于零的 Content-Length 字段值都是有效的。由于对有效载荷的长度没有预定的限制，接收方 **必须** 预计到潜在的大的十进制数字，并防止由于整数转换溢出造成的解析错误（第 9.3 节）。

如果收到的报文有多个 Content-Length 首部字段，其字段值由相同的十进制数值组成，或者有一个 Content-Length 首部字段，其字段值包含一个相同的十进制数值列表（例如。"Content-Length: 42, 42"），表明上游报文处理器生成或合并了重复的 Content-Length 首部字段，那么接收方 **必须** 在确定报文正文长度或转发报文之前，以无效的方式拒绝该报文，或者用包含该十进制值的单一有效 Content-Length 字段替换重复的字段值。

注意：HTTP 在报文分帧中使用 Content-Length 与 MIME 中使用同一字段有很大不同，在 MIME 中它是一个可选字段，只在 “message/external-body” 媒体类型中使用。

### 3.3.3. 报文体长度

报文体的长度由以下一项决定（按优先顺序）：

1. 任何对 HEAD 请求的响应和任何具有 1xx(Informational)、204(No Content)或 304(Not Modified)状态码的响应总是由首部字段之后的第一个空行结束，而不管报文中存在哪些首部字段，因此不能包含报文体。
2. 任何对 CONNECT 请求的 2xx（成功）响应意味着连接将在结束首部字段的空行后立即成为隧道。客户 **必须** 忽略在这种报文中收到的任何 Content-Length 或 Transfer-Encoding 首部字段。
3. 如果有一个 Transfer-Encoding 首部字段，并且分块传输编码（第 4.1 节）是最终的编码，报文体的长度是通过读取和解码分块数据来确定的，直到传输编码表明数据已经完成。

如果响应中出现了 Transfer-Encoding 首部字段，并且分块传输编码不是最终编码，那么报文体的长度是通过读取连接来确定的，直到它被服务器关闭。如果请求中存在 Transfer-Encoding 首部字段，并且分块传输编码不是最终编码，则无法可靠地确定报文体的长度；服务器 **必须** 以 400(Bad Request)状态码进行响应，然后关闭连接。

如果收到的报文同时带有 Transfer-Encoding 和 Content-Length 首部字段，那么 Transfer-Encoding 将覆盖 Content-Length。这样的报文可能表明试图执行请求偷渡（第 9.5 节）或响应分割（第 9.4 节），应该作为错误处理。发送方 **必须** 在向下游转发这样的报文之前删除收到的 Content-Length 字段。

4. 如果收到的报文没有 Transfer-Encoding，并且具有不同字段值的多个 Content-Length 首部字段，或者具有无效值的单个 Content-Length 首部字段，那么报文的分帧是无效的，接收方 **必须** 将其视为不可恢复的错误。如果这是一个请求报文，服务器 **必须** 以 400(Bad Request)状态码进行响应，然后关闭连接。如果这是由代理收到的响应报文，代理 **必须** 关闭与服务器的连接，丢弃收到的响应，并向客户发送 502(Bad Gateway)响应。如果这是由用户代理收到的响应报文，用户代理 **必须** 关闭与服务器的连接，并丢弃收到的响应。
5. 如果有一个有效的 Content-Length 首部字段，而没有 Transfer-Encoding，它的十进制值定义了预期的报文体长度（字节）。如果发送方关闭连接或接收方在收到指定的字节之前超时，接收方 **必须** 认为报文不完整并关闭连接。
6. 如果这是一个请求报文，并且上述情况都不成立，那么报文体长度为零（没有报文体存在）。
7. 否则，这是一个没有声明报文体长度的响应报文，所以报文体长度由服务器关闭连接前收到的字节决定。

由于没有办法区分一个成功完成的、有封闭限制的报文和一个因网络故障而中断的部分接收的报文，服务器 **应该** 尽可能地生成编码或有长度限制的报文。闭合限制功能的存在主要是为了向后兼容 HTTP/1.0。

服务器 **可以** 通过响应 411(Length Required)来拒绝一个包含报文体但没有内容长度的请求。

除非已经应用了分块传输编码以外的传输编码，否则如果事先知道报文体的长度，发送包含报文体的请求的客户 **应该** 使用有效的 Content-Length 首部字段，而不是分块传输编码，因为一些现有的服务以 411(Length Required)状态码响应分块传输，即使它们理解分块传输编码。这通常是因为这些服务是通过一个网关实现的，该网关在被调用之前需要一个内容长度，而服务器不能或不愿意在处理之前缓存整个请求。

如果用户代理不知道服务器将处理 HTTP/1.1（或更高版本）的请求，那么发送包含报文体的请求的用户代理 **必须** 发送一个有效的 Content-Length 首部字段；这种知识可以是特定用户配置的形式，也可以是通过记住先前收到的响应的版本。

如果已经完全收到了对连接上的最后一个请求的最终响应，并且仍然有额外的数据需要读取，那么用户代理 **可以** 丢弃剩余的数据，或者试图确定该数据是否属于先前响应体的一部分，如果先前报文的 Content-Length 值不正确，就会出现这种情况。客户 **不得** 将这种额外的数据作为单独的响应进行处理、缓存或转发，因为这种行为容易导致缓存中毒。

## 3.4. 处理不完整的报文

一个服务器如果收到一个不完整的请求报文，通常是由于一个取消的请求或一个被触发的超时异常，**可以** 在关闭连接之前发送一个错误响应。

客户如果收到不完整的响应报文，这可能发生在连接被提前关闭的情况下，或者当解码一个所谓的分块传输编码失败时，**必须** 将该报文记录为不完整。对不完整响应的缓存要求在[RFC 7234]的第 3 节中定义。

如果响应在首部区域的中间终止（在收到空行之前），并且状态码可能依赖于首部字段来传达响应的全部含义，那么客户不能假定该含义已被传达；客户可能需要重复请求，以确定下一步要采取什么行动。

如果没有收到终止编码的零尺寸块，使用分块传输编码的报文体是不完整的。如果收到的报文体的大小（以八位字节为单位）小于 Content-Length 给出的值，那么使用有效的 Content-Length 的报文是不完整的。一个既没有分块传输编码也没有 Content-Length 的响应因连接的关闭而终止，因此，不管收到的报文体的字节是多少，只要标题部分被完整地收到，就被认为是完整的。

## 3.5. 报文解析健壮性

较早的 HTTP/1.0 用户代理实现可能会在 POST 请求后发送一个额外的 CRLF，作为一些早期服务器应用的变通方法，这些应用无法读取没有行尾的报文体内容。HTTP/1.1 用户代理 **不得** 在请求前面或后面加上一个额外的 CRLF。如果需要用行结结束请求报文体，那么用户代理 **必须** 将结束的 CRLF 字节算作报文体长度的一部分。

为了稳健起见，期待接收和解析请求行的服务器 **应该** 忽略在请求行之前收到的至少一个空行（CRLF）。

尽管起始行和首部字段的行结束符是 CRLF 序列，但接收方 **可以** 将单个 LF 识别为行结束符并忽略前面的 CR。

尽管请求行和状态行的语法规则要求每个组成元素由单个 SP 字节分隔，但接收方 **可以** 在以空格为界限的字边界上进行解析，除了 CRLF 结束符外，将任何形式的空格视为 SP 分隔符，同时忽略前面或后面的空格；这种空格包括以下一个或多个字节。SP、HTAB、VT（%x0B）、FF（%x0C），或裸 CR。然而，如果报文有多个接收方，并且每个接收方对健壮性都有自己独特的解释，那么宽松的解析会导致安全漏洞（见第 9.5 节）。

当一个只监听 HTTP 请求报文的服务器，或者在处理从起始行看来是 HTTP 请求报文的服务器，收到一个不符合 HTTP 报文语法的八进制序列，除了上面列出的健壮性例外，服务器 **应该** 以 400(Bad Request)响应。

# 4. 传输编码

传输编码名称用于表示已经、可以或可能需要应用于有效载荷的编码转换，以确保通过网络 “安全传输”。这与内容编码不同，传输编码是报文的一个属性，而不是传输的表示的一个属性。

```
transfer-coding = "chunked" ; Section 4.1
                  / "compress" ; Section 4.2.1
                  / "deflate" ; Section 4.2.2
                  / "gzip" ; Section 4.2.3
                  / transfer-extension
transfer-extension = token *( OWS ";" OWS transfer-parameter )
```

参数的形式是名称或名称=值对。

```
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
```

所有的传输编码名称都是不区分大小写的，并且应该在 HTTP 传输编码注册表中注册，如第 8.4 节所定义。它们被用于 TE（第 4.3 节）和 Transfer-Encoding（第 3.3.1 节）首部字段中。

## 4.1. 分块传输编码

分块传输编码包裹了有效载荷，以便将其作为一系列分块进行传输，每个分块都有自己的大小指标，后面是包含首部字段的 **可选** 的尾部。分块使未知大小的内容流能够作为一连串有长度限制的缓存区来传输，这使发送方能够保留连接的持续性，而接收方能够知道它何时收到了整个报文。

```
chunked-body = *chunk
               last-chunk
               trailer-part
               CRLF
chunk = chunk-size [ chunk-ext ] CRLF
        chunk-data CRLF
chunk-size = 1*HEXDIG
last-chunk = 1*("0") [ chunk-ext ] CRLF

chunk-data = 1*OCTET ; a sequence of chunk-size octets
```

chunk-size 字段是一串十六进制数字，表示分块数据的字节大小。当收到一个分块大小为 0 的分块时，分块传输编码就完成了，后面可能还有一个 trailer，最后以一个空行结束。

接收方 **必须** 能够解析和解码分块传输编码。

### 4.1.1. 块扩展

分块编码允许每个分块包括零个或多个分块扩展，紧跟在分块大小之后，以便提供每个分块的元数据（如签名或散列）、中间报文控制报文或报文体大小的随机化。

```
chunk-ext = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )

chunk-ext-name = token
chunk-ext-val = token / quoted-string
```

分块编码对每个连接都是特定的，在任何高层应用有机会检查扩展之前，每个接收方（包括中继）都有可能被删除或重新编码。因此，分块扩展的使用通常限于专门的 HTTP 服务，如 "长轮询"（客户和服务器可以对分块扩展的使用有共同的期望）或用于端到端安全连接中的填充。

接收方 **必须** 忽略未被识别的分块扩展。服务器应该将请求中收到的分块扩展的总长度限制在对所提供的服务来说是合理的，就像它对报文的其他部分应用长度限制和超时一样，如果超过了这个数量，就产生一个适当的 4xx(Client Error) 响应。

### 4.1.2. 分块 Trailer-Part

Trailer 允许发送方在分块报文的末尾包括额外的字段，以便提供可能在报文体发送时动态产生的元数据，例如报文完整性检查、数字签名或后处理状态。Trailer 字段与首部字段相同，只是它们是在分块的尾部中发送，而不是在首部部分。

```
trailer-part = *( header-field CRLF )
```

发送方 **不得** 生成包含报文分帧（如 Transfer-Encoding 和 Content-Length）、路由（如 Host）、请求修饰字段（如[RFC 7231]第 5 节的控制和条件）、认证（如，见[RFC 7235]和[RFC 6265]）、响应控制数据（例如，见[RFC 7231]第 7.1 节），或确定如何处理有效载荷（例如，内容编码、内容类型、内容范围和 Trailer）。

当收到包含非空 Trailer 的分块报文时，接收方 **可以** 处理这些字段（除了上面禁止的字段），就像它们被附加到报文的首部区域一样。接收方 **必须** 忽略（或将其视为错误）任何禁止在 Trailer 中发送的字段，因为将其作为首部区域中的字段来处理可能会绕过外部安全过滤器。

除非请求包括一个 TE 首部字段，表明 “Trailer” 是可接受的，如第 4.3 节所述，否则服务器 **不应该** 生成它认为用户代理有必要接收的 Trailer 字段。如果没有包含 “Trailer” 的 TE，服务器应该假定 Trailer 字段可能在通往用户代理的路径上被默默地丢弃。这个要求允许中继将一个去分块的报文转发给 HTTP/1.0 的接收方，而不需要缓存整个响应。

### 4.1.3. 解码分块

对分块传输编码进行解码的过程可以用伪代码表示为：

```
length := 0
read chunk-size, chunk-ext (if any), and CRLF
while (chunk-size > 0) {
  read chunk-data and CRLF
  append chunk-data to decoded-body
  length := length + chunk-size
  read chunk-size, chunk-ext (if any), and CRLF
}
read trailer field
  while (trailer field is not empty) {
  if (trailer field is allowed to be sent in a trailer) {
    append trailer field to existing header fields
  }
  read trailer-field
}
Content-Length := length
Remove "chunked" from Transfer-Encoding
Remove Trailer from existing header fields
```

## 4.2. 压缩编码

下面定义的编码可用于压缩报文的有效载荷。

### 4.2.1. Compress 编码

“compress”编码是一种自适应的 Lempel-Ziv-Welch（LZW）编码[Welch]，通常由 UNIX 文件压缩程序 "compress"产生。接收方 **应该** 认为 "x-compress" 等同于 "compress"。

### 4.2.2. Deflate 编码

“deflate”编码是一种 "zlib"数据格式[RFC 1950]，包含一个 "deflate"压缩数据流[RFC 1951]，使用 Lempel-Ziv（LZ77）压缩算法和 Huffman 编码的组合。

注意：一些不符合要求的实施方案在发送 "deflate" 压缩数据时没有使用 zlib 包装。

### 4.2.3. Gzip 编码

“gzip” 编码是一种带有 32 位循环冗余校验（CRC）的 LZ77 编码，通常由 gzip 文件压缩程序[RFC 1952]产生。一个接收方 **应该** 认为 "x-gzip" 等同于 "gzip"。

## 4.3. TE

请求中的 "TE" 首部字段表明，除了分块传输编码外，客户愿意接受哪些传输编码作为响应，以及客户是否愿意接受分块传输编码中的 Trailer 字段。

TE 字段-值由逗号分隔的传输编码名称列表组成，每个名称允许可选参数（如第 4 节所述），和/或关键字 ”Trailer“。客户 **不得** 在 TE 中发送分块传输编码名称；对于 HTTP/1.1 接收方来说，分块传输总是可以接受的。

```
TE = #t-codings
t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
t-ranking = OWS ";" OWS "q=" rank
rank = ( "0" [ "." 0*3DIGIT ] )
      / ( "1" [ "." 0*3("0") ] )
```

以下是 TE 使用的三个例子：

```http
TE: deflate
TE:
TE: trailers, deflate;q=0.5
```

关键词 "trailers" 的出现表明客户愿意代表自己和任何下游客户接受第 4.1.2 节中定义的分块传输编码中的 Trailer 字段。对于来自中继的请求，这意味着，要么。(a)所有下游客户都愿意接受转发响应中的 Trailer 字段；或者，(b)中继将试图代表下游接收方缓存响应。请注意，HTTP/1.1 没有定义任何方法来限制分块响应的大小，以便中继可以保证缓存整个响应。

当可以接受多个传输编码时，客户 **可以** 使用不区分大小写的 "q" 参数（类似于内容协商字段中使用的 q 值，[RFC 7231]的第 5.3.1 节）按优先级对编码进行排序。等级值是 0 到 1 范围内的实数，其中 0.001 是最不喜欢的，1 是最喜欢的；值为 0 意味着 "不可接受"。

如果 TE 字段值为空或没有 TE 字段，唯一可接受的传输编码是 chunked。没有传输编码的报文总是可以接受的。

由于 TE 首部字段只适用于即时连接，TE 的发送方还 **必须** 在连接首部字段中发送一个 "TE" Connection 选项（第 6.1 节），以防止 TE 域被不支持其语义的中继转发。

## 4.4. Trailer

当一个报文包括一个用分块传输编码的报文体，并且发送方希望在报文的末尾以Trailer字段的形式发送元数据时，发送方 **应该** 在报文体之前生成一个Trailer首部字段，以表明哪些字段将出现在Trailer中。这允许接收方在开始处理正文之前准备好接收元数据，如果报文是流式传输的，并且接收方希望即时确认完整性检查，这就很有用。

```
Trailer = 1#field-name
```

# 5. 报文路由

HTTP 请求报文的路由是由每个客户根据目标资源、客户的代理配置以及建立或重新使用入站连接来决定的。相应的响应路由遵循相同的连接链返回到客户。

## 5.1. 识别目标资源

HTTP 被广泛用于各种应用中，从通用计算机到家用电器。在某些情况下，通信选项在客户的配置中是硬编码的。然而，大多数的 HTTP 客户依靠的是与通用网络浏览器相同的资源识别机制和配置技术。

HTTP 通信是由用户代理出于某种目的发起的。该目的是请求语义的组合，定义在[RFC 7231]中，以及应用这些语义的目标资源。URI 引用（第 2.7 节）通常被用作 “目标资源” 的标识符，用户代理将其解析为绝对形式，以获得 “目标 URI”。目标 URI 不包括引用的片段部分（如果有的话），因为片段标识符被保留给客户处理（[RFC 3986]，第 3.5 节）。

## 5.2. 连接入站

一旦确定了目标 URI，客户就需要决定是否需要网络请求来完成所需的语义，如果需要，该请求应指向哪里。

如果客户有一个缓存[RFC 7234]，并且该请求可以由它来满足，那么该请求通常会首先指向那里。

如果缓存不能满足请求，那么典型的客户将检查其配置，以确定是否要使用代理来满足请求。代理的配置与实现有关，但通常是基于 URI 前缀匹配、选择性授权匹配或两者，而代理本身通常由 “http” 或 “https” URI 识别。如果有代理，客户通过建立（或重复使用）与该代理的连接来进行入站连接。

如果没有适用的代理，典型的客户将调用一个处理程序，通常是针对目标 URI 的方案，直接连接到目标资源的权威。如何实现这一点取决于目标 URI 方案，并由其相关规范定义，类似于本规范为解决 “http”（第 2.7.1 节）和 “https”（第 2.7.2 节）方案而定义的源服务器访问。

关于连接管理的 HTTP 要求在第 6 节中定义。

## 5.3. 请求目标

一旦获得一个入站连接，客户就会发送一个 HTTP 请求报文（第 3 节），请求目标来自于目标 URI。请求目标(request-target)有四种不同的形式，取决于被请求的方法和请求是否是对代理的。

```
请求目标 = 原始形式
          /绝对形式
          /权威形式
          /星号形式
```

### 5.3.1. 原始形式

请求目标的最常见形式是原始形式。

```
原始形式 = 绝对路径 [ "?" query ]
```

当直接向源服务器发出请求时，除了 CONNECT 或全服务器的 OPTIONS 请求（如下所述），客户 **必须** 只发送目标 URI 的绝对路径和查询部分作为请求目标。如果目标 URI 的路径部分是空的，客户 **必须** 发送"/"作为请求目标的起源形式中的路径。按照第 5.4 节的定义，还需要发送一个 Host 首部字段。

例如，一个客户希望检索的资源表示形式为：http://www.example.org/where?q=now，它会直接从源服务器打开（或重新使用）一个TCP 连接到主机 "www.example.org" 的 80 端口，并发送这些行。

```http
GET /where?q=now HTTP/1.1
Host: www.example.org
```

后面是请求报文的其余部分。

### 5.3.2. 绝对形式

当向代理发出请求时，除了 CONNECT 或服务器范围内的 OPTIONS 请求（详见下文），客户 **必须** 以绝对形式发送目标 URI 作为请求目标。

```
绝对形式 = absolute-URI
```

代理被要求从一个有效的缓存中为该请求提供服务（如果可能的话），或者代表客户向下一个入站的代理服务器或直接向请求目标所指示的源服务器发出相同的请求。在第 5.7 节中定义了对这种 "转发" 报文的要求。

一个绝对形式的请求行的例子是：

```http
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
```

为了在未来的 HTTP 版本中允许所有的请求过渡到绝对形式，服务器 **必须** 接受请求中的绝对形式，即使 HTTP/1.1 客户只在向代理的请求中发送。

### 5.3.3. 权威形式

请求目标的权威形式只用于 CONNECT 请求（[RFC 7231]的 4.3.6 节）。

```
权威形式 = authority
```

当提出 CONNECT 请求以通过一个或多个代理建立隧道时，客户 **必须** 只发送目标 URI 的权威部分（不包括任何用户报文及其"@"分隔符）作为请求目标。例如：

```http
CONNECT www.example.com:80 HTTP/1.1
```

### 5.3.4. 星号形式

请求的星号形式只用于整个服务器的 OPTIONS 请求（[RFC 7231]的第 4.3.7 节）。

```
星号形式 = "*"
```

当客户希望请求整个服务器的 OPTIONS，而不是该服务器的特定命名资源时，客户 **必须** 只发送 "\*"（%x2A）作为请求目标。例如：

```http
OPTIONS * HTTP/1.1
```

如果一个代理收到一个绝对形式的请求目标的 OPTIONS 请求，其中 URI 有一个空的路径和没有查询部分，那么请求链上的最后一个代理在转发请求到指定的源服务器时 **必须** 发送一个请求目标为 "\*"。

例如，该请求：

```http
OPTIONS http://www.example.org:8001 HTTP/1.1
```

将由最终代理转发为：

```http
OPTIONS * HTTP/1.1
Host: www.example.org:8001
```

在连接到主机 "www.example.org" 的 8001 端口后。

## 5.4. Host

请求中的 “Host” 首部字段提供了来自目标 URI 的主机和端口信息，使源服务器在为一个 IP 地址上的多个主机名称的请求提供服务时能够区分不同的资源。

```http
Host = uri-host [ ":" port ] ; 2.7.1 节
```

客户 **必须** 在所有 HTTP/1.1 请求报文中发送一个 Host 首部字段。如果目标 URI 包括一个权威部分，那么客户 **必须** 为 Host 发送一个与该权威部分相同的字段值，不包括任何用户报文子部分及其"@"分隔符（第 2.7.1 节）。如果目标 URI 的权威部分缺失或未定义，那么客户 **必须** 发送一个空字段值的 Host 首部字段。

由于 Host 字段值是处理请求的关键报文，用户代理 **应该** 将 Host 作为请求行后的第一个首部字段生成。

例如，向源服务器发出的 <http://www.example.org/pub/WWW/> 的 GET 请求将以下列方式开始。

```http
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

客户 **必须** 在 HTTP/1.1 请求中发送一个 Host 首部字段，即使请求目标是绝对形式的，因为这允许 Host 报文通过可能没有实现 Host 的古老的 HTTP/1.0 代理转发。

当代理收到一个绝对形式的请求目标时，代理 **必须** 忽略收到的 Host 首部字段(如果有的话)，而是用请求目标的主机报文来代替它。一个转发这种请求的代理 **必须** 根据收到的请求目标生成一个新的 Host 字段值，而不是转发收到的 Host 字段值。

由于 Host 首部字段作为一个应用程序级别的路由机制，它经常成为恶意软件的目标，以寻求毒害共享缓存或将请求重定向到一个非预期的服务器。如果拦截代理依赖 Host 字段值将请求重定向到内部服务器，或用作共享缓存中的缓存密钥，而不首先验证被拦截的连接是否针对该主机的有效 IP 地址，那么它就特别容易受到攻击。

对于任何缺少 Host 首部字段的 HTTP/1.1 请求报文，以及任何包含一个以上 Host 首部字段或 Host 首部字段的无效字段值的请求报文，服务器 **必须** 以 400(Bad Request) 状态码响应。

## 5.5. 有效请求 URI

由于请求目标通常只包含用户代理的目标 URI 的一部分，服务器将预定的目标重建为一个 “有效的请求 URI”，以正确地服务于请求。这种重建涉及到服务器的本地配置和请求目标、Host 首部字段和连接上下文中传达的报文。

对于一个用户代理，有效的请求 URI 是目标 URI。

如果请求目标是绝对形式的，有效的请求 URI 与请求目标相同。否则，有效的请求 URI 被构建如下：

如果服务器的配置（或出站网关）提供了一个固定的 URI 方案，该方案将用于有效请求 URI。否则，如果请求是通过 TLS 安全的 TCP 连接接收的，有效请求 URI 的方案是 “https”；如果不是，方案是 “http”。

如果服务器的配置（或出站网关）提供了一个固定的 URI 权威部分，该授权将用于有效请求 URI。如果没有，那么如果请求目标是权威形式的，有效请求 URI 的权威部分与请求目标相同。如果不是，那么如果一个 Host 首部字段被提供了一个非空的字段值，那么权威部分就与 Host 字段值相同。否则，权威部分将被分配给为服务器配置的默认名称，如果连接的传入 TCP 端口号与有效请求 URI 方案的默认端口不同，那么冒号（":"）和传入端口号（十进制）将附加到权威部分上。

如果请求目标是权威形式或星号形式，则有效请求 URI 的组合路径和查询部分为空。否则，组合路径和查询部分与请求目标相同。

有效请求 URI 的组成部分，一旦按上述方式确定，就可以通过连接方案、"://"、权威、组合路径和查询组成部分而组合成绝对 URI 形式。

例 1：通过不安全的 TCP 连接收到以下报文

```http
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
```

有一个有效的请求 URI 为：http://www.example.org:8080/pub/WWW/TheProject.html

例 2：通过 TLS 安全的 TCP 连接收到以下报文

```http
OPTIONS * HTTP/1.1
Host: www.example.org
```

有一个有效的请求 URI 为： https://www.example.org

HTTP/1.0 请求的接收方，如果缺乏 Host 首部字段，可能需要使用启发式方法（例如，检查 URI 路径，以了解特定主机的独特之处），以猜测有效请求 URI 的权威部分。

一旦有效请求 URI 被构建，源服务器需要决定是否通过接收请求的连接为该 URI 提供服务。例如，请求可能被故意或意外地误导，从而使收到的请求目标或主机首部字段中的报文与建立连接的主机或端口不同。如果连接来自一个受信任的网关，这种不一致可能是意料之中的；否则，它可能表明有人试图绕过安全过滤器，欺骗服务器交付非公开内容，或在缓存中注入病毒。关于报文路由的安全考虑，见第 9 节。

## 5.6. 关联请求和响应

HTTP 不包括用于将一个给定的请求报文与其相应的一个或多个响应报文联系起来的请求标识符。因此，它依赖于响应到达的顺序与同一连接上的请求的顺序完全一致。只有当一个或多个报文响应（1xx，见[RFC 7231]第 6.2 节）出现在对同一请求的最终响应之前时，每个请求才有一个以上的响应报文。

在一个连接上有一个以上未完成的请求的客户必须按照发送顺序维护一个未完成的请求列表，并且必须将该连接上收到的每个响应报文与尚未收到最终（非 1xx）响应的最高顺序的请求相关联。

## 5.7. 报文转发

如第 2.3 节所述，在处理 HTTP 请求和响应的过程中，中继可以发挥各种作用。一些中继被用来提高性能或可用性。其他的则是用于访问控制或过滤内容。由于 HTTP 流具有类似于流水线和过滤器架构的特点，对于中继可以增强（或干扰）流的任何方向的程度，没有固有的限制。

不作为隧道的中继 **必须** 实现第 6.1 节中规定的 Connection 首部字段，并排除转发只为传入连接准备的字段。

中继 **不得** 将报文转发给自己，除非它被保护不受无限的请求循环影响。一般来说，中继应该识别它自己的服务器名称，包括任何别名、本地变化或字面 IP 地址，并直接响应这种请求

### 5.7.1. Via

“Via”首部字段表示用户代理和服务器之间（关于请求）或源服务器和客户之间（关于响应）存在中间协议和接收方，类似于电子邮件中的 "Received" 首部字段（[RFC 5322]第 3.6.7 节）。Via 可用于跟踪报文转发，避免请求循环，以及识别请求/响应链上的的协议能力。

```
Via = 1#( received-protocol RWS received-by [ RWS comment ] )

received-protocol = [ protocol-name "/" ] protocol-version
                    ; see Section 6.7
received-by = ( uri-host [ ":" port ] ) / pseudonym
pseudonym = token
```

多个 Via 字段值代表每个转发报文的代理或网关。每个中继都会附加自己的报文，说明报文是如何被接收的，这样最终的结果就会根据转发接收方的顺序来排序。

一个代理 **必须** 在它转发的每个报文中发送一个适当的 Via 首部字段，如下所述。一个 HTTP-to-HTTP 网关必须在每个入站请求报文中发送一个适当的 Via 首部字段，并可能在转发的响应报文中发送一个 Via 首部字段。

对于每个中继，received-protocol 表示报文的上游所使用的协议和协议版本。因此，Via 字段的值记录了请求/响应链的广告协议能力，从而使它们对下游接收方保持可见；这对于确定在响应中或在以后的请求中使用哪些向后兼容的功能可能是有用的，如第 2.6 节中所述。为了简洁起见，当收到的协议是 HTTP 时，协议名被省略了。

字段值的 received-by 部分通常是随后转发报文的接收服务器或客户的主机和可选端口号。然而，如果真实的主机被认为是敏感报文，发送方可以用假名代替它。如果没有提供端口，接收方可以将其解释为是在默认的 TCP 端口上收到的，如果有的话，用于接收协议。

发送方 **可以** 在 Via 首部字段中生成注释，以识别每个接收方的软件，类似于 User-Agent 和 Server 首部字段。然而，Via 字段中的所有注释都是可选的，接收方 **可以** 在转发报文之前删除它们。

例如，一个请求报文可以从一个 HTTP/1.0 的用户代理发送至一个代号为 "fred" 的内部代理，该代理使用 HTTP/1.1 将请求转发至一个位于 p.example.net 的公共代理，该代理通过将请求转发至位于www.example.com的源服务器完成请求。www.example.com 收到的请求将有以下 Via 首部字段。

```http
Via: 1.0 fred, 1.1 p.example.net
```

作为通过网络防火墙的门户的中继不应转发防火墙区域内的主机的名称和端口，除非它被明确地启用。如果不启用，这样的中继 **应该** 用该主机的适当假名替换防火墙后面任何主机的每个接收到的主机。

如果条目具有相同的接收协议值，中继 **可以** 将 Via 首部字段条目的有序子序列合并为一个这样的条目。例如。

```http
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```

could be collapsed to

```http
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

发送方 **不应该** 合并多个条目，除非它们都在同一组织控制之下，并且主机已经被假名所取代。发送方 **不得** 合并具有不同接收协议值的条目。

### 5.7.2. 转译

一些中继包括转换报文和其有效载荷的功能。例如，一个代理可能在图像格式之间进行转换，以节省缓存空间或减少慢速链接上的流量。然而，当这些转换被应用于关键应用的有效载荷时，如医学成像或科学数据分析，特别是当完整性检查或数字签名被用来确保收到的有效载荷与原件相同时，可能会出现操作问题。

如果一个 HTTP-to-HTTP 代理被设计或配置为以有语义的方式修改报文（即，超出正常 HTTP 处理要求的修改，以对原始发送方有意义或对下游接收方有潜在意义的方式改变报文），则称为 "转换代理"。例如，一个转换代理可能作为一个共享的注释服务器（修改响应以包括对本地注释数据库的引用）、一个恶意软件过滤器、一个格式转码器或一个隐私过滤器。这样的转换被认为是哪个客户（或客户组织）选择代理所希望的。

如果一个代理收到的请求目标的主机名不是完全合格的域名，它 **可以** 在转发请求时将自己的域名添加到它收到的主机名上。如果请求目标包含一个完全合格的域名，代理 **不得** 改变主机名。

当转发到下一个入站服务器时，代理 **不得** 修改所收到的请求目标的 "绝对路径 "和 "查询 "部分，除非如上所述，用"/"或 "\*"替换一个空路径。

代理 **可以** 通过应用或删除传输编码来修改报文体（第 4 节）。

代理 **不得** 转换包含无转换缓存控制指令（[RFC 7234]第 5.2 节）的报文的有效载荷（[RFC 7231]第 3.3 节）。

代理 **可以** 会转换不包含无转换缓存控制指令的报文的有效载荷。对有效载荷进行转换的代理 **必须** 添加警告首部字段，其警告代码为 214(Transformation Applied)，如果报文中还没有这个字段的话（参见[RFC 7234]第 5.5 节）。对 200(OK)响应的有效载荷进行转换的代理可以通过将响应状态码改为 203(Non-Authoritative Information)来进一步通知下游接收方已经应用了转换（[RFC 7231]的第 6.3.4 节）。

代理 **不应该** 修改提供通信链端点、资源状态或所选表示方式（除有效载荷外）报文的首部字段，除非该字段的定义特别允许这种修改，或者该修改被认为对隐私或安全有必要。

# 6. 连接管理

HTTP 报文传输是独立于底层传输层或会话层连接协议的。HTTP 只假定有一个可靠的传输，可以按顺序交付请求和相应地按顺序交付响应。将 HTTP 请求和响应结构映射到底层传输协议的数据单元上，不属于本规范的范围。

如第 5.2 节所述，用于 HTTP 交互的具体连接协议是由客户配置和目标 URI 决定的。例如，“http” URI 方案（第 2.7.1 节）指出了 TCP over IP 的默认连接，默认的 TCP 端口为 80，但客户可能被配置为通过其他连接、端口或协议使用代理。

HTTP 实现被期望参与连接管理，这包括维护当前连接的状态，建立一个新的连接或重新使用一个现有的连接，处理连接上收到的报文，检测连接失败，以及关闭每个连接。大多数客户并行地维护多个连接，包括每个服务器端点的一个以上的连接。大多数服务器被设计为维护数千个并发连接，同时控制请求队列以实现公平使用和检测拒绝服务攻击。

## 6.1. Connection

"Connection"首部字段允许发送方指出当前连接所需的控制选项。为了避免混淆下游接收方，代理或网关 **必须** 在转发报文之前删除或替换任何收到的 Connection 选项。

当除了 Connection 以外的首部字段被用来为当前连接提供控制信息时，发送方 **必须** 在 Connection 首部字段中列出相应的字段名。代理或网关 **必须** 在转发消息之前解析收到的 Connection 首部字段，并且对于该域中的每个 Connection 选项，删除报文中与 Connection 选项同名的任何首部字段，然后删除 Connection 首部字段本身（或用中继自己的 Connection 选项替换转发的报文）。

因此，Connection 首部字段提供了一种声明性的方式来区分只针对直接接收方的首部字段（“逐跳”）和针对链上所有接收方的首部字段（“端到端”），使报文能够自我描述，并允许未来的特定连接扩展被部署，而不用担心它们会被老的中继盲目转发。

Connection 字段的值有以下语法。

```
Connection = 1#connection-option connection-option = token`
```

Connection 选项是不区分大小写的。

发送方 **不得** 发送一个与首部字段相对应的 Connection 选项，该首部字段是为有效载荷的所有接收方准备的。例如，Cache-Control 就不适合作为 Connection 选项（[RFC 7234]第 5.2 节）。

Connection 选项并不总是对应于报文中存在的首部字段，因为如果没有与 Connection 选项相关的参数，可能就不需要特定的连接首部字段。相反，如果收到的特定 Connection 首部字段没有相应的 Connection 选项，通常表明该字段被中继不适当地转发，应该被接收方忽略。

在定义新的 Connection 选项时，规范制定者应该调查现有的首部字段名称，并确保新的 Connection 选项不与已经部署的首部字段共享相同的名称。定义一个新的 Connection 选项实质上是保留了这个潜在的字段名，用于携带与 Connection 选项相关的额外信息，因为发送方将这个字段名用于其他方面是不明智的。

“close” Connection 选项是为发送方定义的，以示该连接将在响应完成后被关闭。例如

```http
Connection: close
```

在请求或响应首部字段中，表示发送方在当前请求/响应完成后将关闭连接（第 6.6 节）。

不支持持续性连接的客户 **必须** 在每个请求报文中发送 “close” 连接选项。

不支持持续连接的服务器 **必须** 在每个没有 1xx (Informational)状态码的响应报文中发送 “close” 连接选项。

## 6.2. 建立

描述如何通过各种传输层或会话层协议建立连接，超出了本规范的范围。每个连接只适用于一个传输链路。

## 6.3. 持续

HTTP/1.1 默认使用 “持续连接”，允许在一个连接上进行多个请求和响应。“close”连接选项被用来表示一个连接在当前请求/响应之后将不会持续存在。HTTP 实现 **应该** 支持持续性连接。

接收方根据最近收到的报文的协议版本和 Connection 首部字段（如果有的话）来决定一个连接是否是持续的。

- 如果 “close” 连接选项存在，那么在当前响应之后，连接将不会持续存在；否则，
- 如果收到的协议是 HTTP/1.1（或更高版本），该连接将在当前响应后持续存在；否则，
- 如果收到的协议是 HTTP/1.0，“keep-alive”连接选项存在，接收方不是代理，并且接收方希望尊重 HTTP/1.0 “keep-alive”机制，连接将在当前响应后持续存在；否则，
- 连接将在当前响应后关闭。

客户 **可以** 在一个持续的连接上发送额外的请求，直到它发送或收到一个 “close” 连接选项，或者收到一个没有 “keep-alive” 连接选项的 HTTP/1.0 响应。

为了保持持续性，如第 3.3 节所述，连接上的所有报文需要有一个自我定义的报文长度（即，一个不由关闭连接定义的长度）。服务器 **必须** 阅读整个请求报文体，或者在发送其响应后关闭连接，因为否则持续性连接上的剩余数据会被误解为下一个请求。同样地，如果客户打算在随后的请求中重新使用同一个连接，则 **必须** 阅读整个响应报文体。

代理服务器 **不得** 与 HTTP/1.0 客户保持持续的连接（关于许多 HTTP/1.0 客户实现的 Keep-Alive 首部字段的信息和讨论，见[RFC 2068]的第 19.7.1 节）。

关于与 HTTP/1.0 客户的向后兼容性的更多信息，见附录 A.1.2。

### 6.3.1. 重试请求

连接可以在任何时候被关闭，无论是否有意图。实现应该预见到从异步关闭事件中恢复的需要。

当一个入站连接被提前关闭时，如果所有这些请求都有同位素方法，客户 **可以** 打开一个新的连接并自动重传一个被放弃的请求序列（[RFC 7231]第 4.2.2 节）。代理 **不得** 自动重试非同位素的请求。

用户代理 **不得** 自动重试具有非 empotent 方法的请求，除非它有某种方法知道请求语义实际上是 idempotent 的，不管是什么方法，或者有某种方法检测原始请求从未被应用。例如，一个知道（通过设计或配置）对特定资源的 POST 请求是安全的用户代理可以自动重复该请求。同样，一个专门设计用于操作版本控制库的用户代理可能能够通过在连接失败后检查目标资源的修订版，恢复或修复任何部分应用的变化，然后自动重试失败的请求，从而从部分失败条件中恢复。

客户 **不应该** 自动重试失败的自动重试。

### 6.3.2. 流水线

支持持续连接的客户 **可以** 对其请求使用流水线（即，发送多个请求而不等待每个响应）。如果一连串的流水线请求都有安全的方法，服务器 **可以** 并行处理这些请求（[RFC 7231]第 4.2.1 节），但是它必须按照接收请求的相同顺序发送相应的响应。

如果连接在它收到所有相应的响应之前关闭，流水线请求的客户 **应该** 重试未响应的请求。当在一个失败的连接（一个没有被服务器在其最后的完整响应中明确关闭的连接）之后重试流水线请求时，客户 **不得** 在连接建立之后立即进行流水线处理，因为先前流水线中的第一个剩余请求可能已经引起了错误响应，如果在一个过早关闭的连接上发送多个请求，就会再次丢失（参见第 6.6 节中描述的 TCP 复位问题）。

Idempotent 方法（[RFC 7231]第 4.2.2 节）对流水线很重要，因为它们可以在连接失败后自动重试。用户代理 **不应该** 在非 empotent 方法之后进行流水线请求，直到收到该方法的最终响应状态码，除非用户代理有办法检测和恢复涉及流水线序列的部分故障条件。

收到流水线化请求的中继在转发入站时 **可以** 对这些请求进行流水线化，因为它可以依靠出站的用户代理来确定哪些请求可以安全地进行流水线化。如果入站连接在收到响应之前失败，那么如果请求都有同位素方法，流水线化中继 **可以** 尝试重试尚未收到响应的请求序列；否则，流水线化中继 **应该** 转发任何收到的响应，然后关闭相应的出站连接，以便出站用户代理能够相应地恢复。

## 6.4. 并发

客户应该限制它与一个给定的服务器同时打开的连接数。

以前的 HTTP 修订版给出了一个特定的连接数作为上限，但这对于许多应用来说是不切实际的。因此，本规范并没有规定一个特定的最大连接数，而是鼓励客户在打开多个连接时要保守一些。

多个连接通常用于避免 "头部阻塞" 问题，即一个需要大量服务器端处理的请求和/或具有大的有效载荷的请求会阻塞同一连接上的后续请求。在同一连接上的后续请求。然而，每个连接都会消耗服务器资源。此外，在拥挤的网络中，使用多个连接可能会导致不理想的副作用。

请注意，服务器可能会拒绝它认为是滥用或具有拒绝服务攻击特征的流量，例如来自单一客户的过多的开放连接。

## 6.5. 失败和超时

服务器通常会有一些超时值，超过这个值就不再维持一个不活动的连接。代理服务器可能会使这个值更高，因为客户可能会通过同一个代理服务器进行更多的连接。持续连接的使用对客户或服务器的超时长度（或存在）没有任何要求。

希望超时的客户或服务器 **应该** 在连接上发出一个优雅的关闭。实现 **应该** 不断地监控开放的连接，以接收关闭信号，并在适当的时候对其作出响应，因为及时关闭连接的双方可以回收分配的系统资源。

客户、服务器或代理 **可以** 在任何时候关闭传输连接。例如，在服务器决定关闭 "空闲" 连接的同时，客户可能已经开始发送一个新的请求。从服务器的角度来看，连接是在空闲时被关闭的，但从客户的角度来看，一个请求正在进行中。

在可能的情况下，服务器 **应该** 维持持续的连接，并允许底层传输的流量控制机制来解决暂时的过载问题，而不是终止连接，期望客户会重试。后者的技术可能会加剧网络拥堵。

发送报文体的客户在传输请求的同时，**应该** 监测网络连接是否有错误响应。如果客户看到一个响应，表明服务器不希望收到报文体并正在关闭连接，那么客户 **应该** 立即停止传输消息体，并关闭它的连接。

## 6.6. 拆除

Connection 首部字段（第 6.1 节）提供了一个 “close”连接选项，当发送方希望在当前请求/响应对之后关闭连接时，**应该** 发送该选项。

发送 “close”连接选项的客户 **不得** 再在该连接上发送进一步的请求（在包含 “close” 的请求之后），并且 **必须** 在读取与该请求相对应的最终响应报文之后关闭该连接。

收到 “close” 连接选项的服务器 **必须** 在发送对包含 "关闭"的请求的最后响应后启动关闭连接（见下文）。服务器 **应该** 在其对该连接的最后响应中发送一个 “close” 连接选项。服务器 **不得** 处理在该连接上收到的任何进一步的请求。

发送 “close” 连接选项的服务器 **必须** 在其发送包含 “close” 的响应后启动关闭连接（见下文）。服务器 **不得** 处理在该连接上收到的任何进一步的请求。

收到 “close” 连接选项的客户 **必须** 停止在该连接上发送请求，并在读取包含 “close” 的响应报文后关闭该连接；如果在该连接上发送了额外的流水线请求，客户 **不应该** 认为它们将被服务器处理。

如果服务器立即关闭一个 TCP 连接，就有很大的风险，客户将无法读取最后的 HTTP 响应。如果服务器在一个完全关闭的连接上收到来自客户的额外数据，例如在收到服务器的响应之前客户发送的另一个请求，服务器的 TCP 堆栈将向客户发送一个复位分组；不幸的是，复位分组可能会在客户的 HTTP 解析器能够读取和解释之前，擦除客户的未确认的输入缓存区。

为了避免 TCP 重置问题，服务器通常分阶段关闭连接。首先，服务器执行半关闭，只关闭读/写连接的写端。然后，服务器继续从该连接中读取数据，直到它收到客户的相应关闭，或者直到服务器合理地确定它自己的 TCP 堆栈已经收到客户对包含服务器最后响应的分组的确认。最后，服务器完全关闭连接。

目前还不知道重置问题是 TCP 独有的，还是也可能在其他传输连接协议中发现。

## 6.7. Upgrade

“Upgrade”首部字段的目的是提供一种简单的机制，以便在同一连接上从 HTTP/1.1 过渡到其他一些协议。客户 **可以** 在请求的 Upgrade 首部字段中发送一个协议列表，以邀请服务器在发送最终响应之前按优先级的顺序切换到这些协议中的一个或多个。如果服务器希望在该连接上继续使用当前协议，它 **可以** 忽略收到的 Upgrade 首部字段。升级不能被用来坚持协议的改变。

```
Upgrade = 1#protocol

protocol = protocol-name ["/" protocol-version]
protocol-name = token
protocol-version = token
```

发送 101(Switching Protocols)响应的服务器 **必须** 发送一个 Upgrade 首部字段，以指示连接被切换到的新协议；如果多个协议层被切换，发送方 **必须** 按照层级递增的顺序列出协议。服务器 **不得** 切换到客户在相应请求的 Upgrade 首部字段中没有指明的协议。服务器 **可以** 选择忽略客户指示的偏好顺序，并根据其他因素选择新的协议，例如请求的性质或服务器上的当前负载。

发送 426(Upgrade Required)响应的服务器 **必须** 发送一个 Upgrade 首部字段，以指示可接受的协议，按优先级递减的顺序。

服务器 **可以** 在任何其他响应中发送 Upgrade 首部字段，以表明它支持在适合未来请求的情况下按优先级递减的顺序升级到所列协议。

下面是一个由客户发送的假想的例子：

```http
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

协议变更后的应用级通信的能力和性质完全取决于所选择的新协议。然而，在发送 101(Switching Protocols)响应后，服务器被期望继续响应原始请求，就像它在新协议中收到了它的等价物一样（即，在协议改变后，服务器仍然有一个未完成的请求要满足，并且被期望这样做而不要求重复请求）。

例如，如果在 GET 请求中收到 Upgrade 首部字段，服务器决定切换协议，它首先在 HTTP/1.1 中响应 101(Switching Protocols)报文，然后立即用新协议的等价物对目标资源的 GET 进行响应。这允许连接升级到具有与 HTTP 相同语义的协议，而没有额外往返的延迟成本。除非收到的报文语义能够被新的协议接受，否则服务器 **不得** 切换协议；OPTIONS 请求可以被任何协议接受。

下面是对上述假设请求的一个响应示例：

```http
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: HTTP/2.0

[... data stream switches to HTTP/2.0 with an appropriate response
(as defined by new protocol) to the "GET /hello.txt" request ...]
```

当 Upgrade 被发送时，发送方也 **必须** 发送一个包含 "Upgrade" 连接选项的 Connection 首部字段（第 6.1 节），以防止 Upgrade 被可能不执行所列协议的中继意外地转发出去。服务器 **必须** 忽略在 HTTP/1.0 请求中收到的 Upgrade 首部字段。

客户不能在连接上开始使用升级的协议，直到它完全发送了请求报文（即，客户不能在报文的中间改变它正在发送的协议）。如果服务器同时收到升级和带有 "100-continue"期望的 Expect 首部字段（[RFC 7231]第 5.1.1 节），服务器 **必须** 在发送 101(Switching Protocols)响应之前发送 100（继续）响应。

Upgrade 首部字段只适用于在现有连接之上切换协议；它不能用于切换底层连接（传输）协议，也不能用于将现有通信切换到不同的连接。对于这些目的，使用 3xx(Redirection)响应更合适（[RFC 7231]第 6.4 节）。

本规范只定义了协议名称 "HTTP"，供超文本传输协议家族使用，由第 2.6 节的 HTTP 版本规则和本规范的未来更新所定义。额外的标记应该使用第 8.6 节中定义的注册程序向 IANA 注册。

# 7. ABNF 列表扩展：#规则

对[RFC 5234]的 ABNF 规则的#规则扩展被用来提高一些首部字段值定义的可读性。

定义了一个结构 "#"，类似于 "\*"，用于定义以逗号分隔的元素列表。完整的形式是 "<n>#<m>element"，表示至少<n>和最多<m>个元素，每个元素之间用一个逗号（","）和可选的空白（OWS）分开。

在任何使用列表结构的产生式中，发送方 **不得** 产生空的列表元素。换句话说，发送方 **必须** 生成满足以下语法的列表。

```
1#element => element *( OWS "," OWS element )
```

和：

```
#element => [ 1#element ]
```

以及对于 n >= 1 and m > 1:

```
<n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )
```

为了与传统的列表规则兼容，接收方 **必须** 解析并忽略合理数量的空列表元素：足以处理发送方合并值的常见错误，但不能多到可以用作拒绝服务机制。换句话说，接收方 **必须** 接受满足以下语法的列表：

```
#element => [ ( "," / element ) *( OWS "," [ OWS element ] ) ]
1#element => *( "," OWS ) element *( OWS "," [ OWS element ] )
```

空的元素对存在的元素数没有贡献。例如，鉴于这些 ABNF 产生式：

```
example-list = 1#example-list-elmt
example-list-elmt = token ; see Section 3.2.6
```

那么以下是 example-list 的有效值（不包括双引号，双引号的存在只是为了定界）：

```
"foo,bar"
"foo ,bar,"
"foo , ,bar,charlie "
```

相反，下面的值将是无效的，因为至少有一个非空的元素是例子-列表产生式所要求的：

```
""
","
", ,"
```

附录 B 显示了收集到的列表结构扩展后的接收方 ABNF。
