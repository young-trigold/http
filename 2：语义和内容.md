**目录：**

- [1. 简介](#1-简介)
  - [1.1. 符合性和错误处理](#11-符合性和错误处理)
  - [1.2. 语法记号](#12-语法记号)
- [2. 资源](#2-资源)
- [3. 表示](#3-表示)
  - [3.1. 表示元数据](#31-表示元数据)
    - [3.1.1. 处理表示数据](#311-处理表示数据)
      - [3.1.1.1. 媒体类型](#3111-媒体类型)
      - [3.1.1.2. Charset](#3112-charset)
      - [3.1.1.3. 编码和文本缺省](#3113-编码和文本缺省)
      - [3.1.1.4. Multipart 类型](#3114-multipart-类型)
      - [3.1.1.5. Content-Type](#3115-content-type)
    - [3.1.2. 压缩或完整性的编码](#312-压缩或完整性的编码)
      - [3.1.2.1. 内容编码](#3121-内容编码)
      - [3.1.2.2. Content-Encoding](#3122-content-encoding)
    - [3.1.3. 受众语言](#313-受众语言)
      - [3.1.3.1. 语言标签](#3131-语言标签)
      - [3.1.3.2. Content-Language](#3132-content-language)
    - [3.1.4. 识别](#314-识别)
      - [3.1.4.1. 识别一个表示](#3141-识别一个表示)
      - [3.1.4.2. Content-Location](#3142-content-location)
  - [3.2. 表示数据](#32-表示数据)
  - [3.3. 有效载荷语义](#33-有效载荷语义)
  - [3.4. 内容协商](#34-内容协商)
    - [3.4.1. 主动协商](#341-主动协商)
    - [3.4.2. 被动协商](#342-被动协商)
- [4. 请求方法](#4-请求方法)
  - [4.1. 概览](#41-概览)
  - [4.2. 常见方法的属性](#42-常见方法的属性)
    - [4.2.1. 安全方法](#421-安全方法)
    - [4.2.2. 幂等方法](#422-幂等方法)
    - [4.2.3. 可缓存方法](#423-可缓存方法)
  - [4.3. 方法定义](#43-方法定义)
    - [4.3.1. GET](#431-get)
    - [4.3.2. HEAD](#432-head)
    - [4.3.3. POST](#433-post)
    - [4.3.4. PUT](#434-put)
    - [4.3.5. DELETE](#435-delete)
    - [4.3.6. CONNECT](#436-connect)
    - [4.3.7. OPTIONS](#437-options)
    - [4.3.8. TRACE](#438-trace)
- [5. 请求首部字段](#5-请求首部字段)
  - [5.1. 控制](#51-控制)
    - [5.1.1. Expect](#511-expect)
    - [5.1.2. Max-Forwards](#512-max-forwards)
  - [5.2. 条件](#52-条件)
  - [5.3. 内容协商](#53-内容协商)
    - [5.3.1. 质量值](#531-质量值)
    - [5.3.2. Accept](#532-accept)
    - [5.3.3. Accept-Charset](#533-accept-charset)
    - [5.3.4. Accept-Encoding](#534-accept-encoding)
    - [5.3.5. Accept-Language](#535-accept-language)
  - [5.4. 认证凭据](#54-认证凭据)
  - [5.5. 请求上下文](#55-请求上下文)
    - [5.5.1. From](#551-from)
    - [5.5.2. Referer](#552-referer)
    - [5.5.3. User-Agent](#553-user-agent)
- [6. 响应状态码](#6-响应状态码)
  - [6.1. 状态码概览](#61-状态码概览)
  - [6.2. 信息 1xx](#62-信息-1xx)
    - [6.2.1. 100 Continue](#621-100-continue)
    - [6.2.2. 101 Switching Protocols](#622-101-switching-protocols)
  - [6.3. 成功 2xx](#63-成功-2xx)
    - [6.3.1. 200 OK](#631-200-ok)
    - [6.3.2. 201 Created](#632-201-created)
    - [6.3.3. 202 Accepted](#633-202-accepted)
    - [6.3.4. 203 Non-Authoritative Information](#634-203-non-authoritative-information)
    - [6.3.5. 204 No Content](#635-204-no-content)
    - [6.3.6. 205 Reset Content](#636-205-reset-content)
  - [6.4. 重定向 3xx](#64-重定向-3xx)
    - [6.4.1. 300 Multiple Choices](#641-300-multiple-choices)
    - [6.4.2. 301 Moved Permanently](#642-301-moved-permanently)
    - [6.4.3. 302 Found](#643-302-found)
    - [6.4.4. 303 See Other](#644-303-see-other)
    - [6.4.5. 305 Use Proxy](#645-305-use-proxy)
    - [6.4.6. 306 (Unused)](#646-306-unused)
    - [6.4.7. 307 Temporary Redirect](#647-307-temporary-redirect)
  - [6.5. 客户错误 4xx](#65-客户错误-4xx)
    - [6.5.1. 400 Bad Request](#651-400-bad-request)
    - [6.5.2. 402 Payment Required](#652-402-payment-required)
    - [6.5.3. 403 Forbidden](#653-403-forbidden)
    - [6.5.4. 404 Not Found](#654-404-not-found)
    - [6.5.5. 405 Method Not Allowed](#655-405-method-not-allowed)
    - [6.5.6. 406 Not Acceptable](#656-406-not-acceptable)
    - [6.5.7. 408 Request Timeout](#657-408-request-timeout)
    - [6.5.8. 409 Conflict](#658-409-conflict)
    - [6.5.9. 410 Gone](#659-410-gone)
    - [6.5.10. 411 Length Required](#6510-411-length-required)
    - [6.5.11. 413 Payload Too Large](#6511-413-payload-too-large)
    - [6.5.12. 414 URI Too Long](#6512-414-uri-too-long)
    - [6.5.13. 415 Unsupported Media Type](#6513-415-unsupported-media-type)
    - [6.5.14. 417 Expectation Failed](#6514-417-expectation-failed)
    - [6.5.15. 426 Upgrade Required](#6515-426-upgrade-required)
  - [6.6. 服务器错误 5xx](#66-服务器错误-5xx)
    - [6.6.1. 500 Internal Server Error](#661-500-internal-server-error)
    - [6.6.2. 501 Not Implemented](#662-501-not-implemented)
    - [6.6.3. 502 Bad Gateway](#663-502-bad-gateway)
    - [6.6.4. 503 Service Unavailable](#664-503-service-unavailable)
    - [6.6.5. 504 Gateway Timeout](#665-504-gateway-timeout)
    - [6.6.6. 505 HTTP Version Not Supported](#666-505-http-version-not-supported)
- [7. 响应首部字段](#7-响应首部字段)
  - [7.1. 控制数据](#71-控制数据)
    - [7.1.1. 发起日期](#711-发起日期)
      - [7.1.1.1. 日期/时间 格式](#7111-日期时间-格式)
      - [7.1.1.2. Date](#7112-date)
    - [7.1.2. Location](#712-location)
    - [7.1.3. Retry-After](#713-retry-after)
    - [7.1.4. Vary](#714-vary)
  - [7.2. 验证器首部字段](#72-验证器首部字段)
  - [7.3. 认证挑战](#73-认证挑战)
  - [7.4. 响应环境](#74-响应环境)
    - [7.4.1. Allow](#741-allow)
    - [7.4.2. Server](#742-server)

# 1. 简介

每个超文本传输协议（HTTP）报文都是一个请求或一个响应。服务器在连接上监听请求，解析收到的每个报文，解释与确定的请求目标有关的报文语义，并以一个或多个响应报文来响应该请求。客户构造请求报文以传达特定的意图，检查收到的响应以查看意图是否被执行，并决定如何解释结果。本文件根据[RFC 7230]中定义的架构，定义了 HTTP/1.1 请求和响应语义。

HTTP 提供了一个与资源交互的统一接口（第 2 节），无论其类型、性质或实现如何，都可以通过操作和传输表示（第 3 节）。

HTTP 语义包括每个请求方法所定义的意图（第 4 节）、可能在请求首部字段中描述的对这些语义的扩展（第 5 节）、表示机器可读响应的状态码的含义（第 6 节），以及可能在响应首部字段中给出的其他控制数据和资源元数据的含义（第 7 节）。

本文还定义了描述接收方如何解释有效载荷的表示元数据、可能影响内容选择的请求首部字段，以及统称为 “内容协商” 的各种选择算法（第 3.4 节）。

## 1.1. 符合性和错误处理

本文档中的关键词 “必须”、“不得”、“需要”、“应当”、“不应当”、“应该”、“不应该”、“推荐”、“可以” 和 “可选” 应按照[RFC 2119]中的描述进行解释。

有关错误处理的符合性标准和注意事项在[RFC 7230] 第 2.5 节中定义。

## 1.2. 语法记号

本规范使用[RFC 5234]的 Augmented Backus-Naur Form（ABNF）符号，并在[RFC 7230]的第 7 节中定义了一个列表扩展，允许使用'#'操作符（类似于'\*'操作符表示重复的方式）紧凑地定义逗号分隔的列表。附录 C 描述了从其他文件中导入的规则。附录 D 显示了收集到的语法，其中所有的列表操作符都扩展为标准的 ABNF 符号。

本规范使用术语 “字符”、“字符编码方案”、“字符集” 和 “协议元素”，它们在[RFC 6365]中被定义。

# 2. 资源

一个 HTTP 请求的目标被称为 **资源(resource)**。HTTP 并不限制资源的性质；它只是定义了一个可能被用来与资源交互的接口。每个资源都由一个统一资源标识符（URI）来识别，如[RFC 7230]第 2.7 节所述。

当客户构建 HTTP/1.1 请求报文时，它以各种形式之一发送目标 URI，如（[RFC 7230]第 5.3 节）所定义。当收到请求时，服务器为目标资源重构一个有效的请求 URI（[RFC 7230]第 5.5 节）。

HTTP 的一个设计目标是将资源识别与请求语义分开，这一点通过将请求语义归入请求方法（第 4 节）和一些修改请求的首部字段（第 5 节）而得以实现。如第 4.2.1 节所述，如果方法语义与 URI 本身所隐含的任何语义之间存在冲突，则方法语义优先。

# 3. 表示

考虑到资源可以是任何东西，而 HTTP 提供的统一接口类似于一个窗口，通过这个窗口，人们只能通过与另一边的一些独立行为者的报文通信来观察和处理这样的东西，因此需要一个抽象来表示（“代替”）该东西在我们通信中的当前或期望状态。这种抽象被称为 **表示(representation)**[REST]。

就 HTTP 而言，表示是指旨在反映特定资源的过去、当前或期望状态的信息，其格式可以很容易地通过协议进行通信，并由一组表示元数据和可能无限制的表示数据流组成。

一个源服务器可能被提供或能够生成多个表示，每个表示都旨在反映目标资源的当前状态。在这种情况下，源服务器会使用一些算法来选择其中一个最适用于特定请求的表示，通常是基于内容协商。这种 “选定的表示” 被用来提供数据和元数据，以评估条件请求[RFC 7232]，并为 GET 的 200(OK)和 304(Not Modified) 响应构建有效载荷（第 4.3.1 节）。

## 3.1. 表示元数据

表示首部字段提供关于表示的元数据。当一个报文包括一个有效载荷时，表示首部字段描述了如何解释有效载荷中包含的表示数据。在对 HEAD 请求的响应中，表示首部字段描述了如果同一请求是 GET，就会被包含在有效载荷中的表示数据。

下面的首部字段传达了表示元数据：

| 字段名           | 定义在     |
| ---------------- | ---------- |
| Content-Type     | 3.1.1.5 节 |
| Content-Encoding | 3.1.2.2 节 |
| Content-Language | 3.1.3.2 节 |
| Content-Location | 3.1.4.2 节 |

### 3.1.1. 处理表示数据

#### 3.1.1.1. 媒体类型

HTTP 在 Content-Type（第 3.1.1.5 节）和 Accept（第 5.3.2 节）首部字段中使用 Internet 媒体类型(media-type)[RFC 2046]，以便提供开放和可扩展的数据类型和类型协商。媒体类型既定义了数据格式，也定义了各种处理模式：如何根据接收数据的各个环境来处理这些数据。

```
media-type = type "/" subtype *( OWS ";" OWS parameter )
type = token
subtype = token
```

类型/子类型后面 **可以** 跟上名称=值对形式的参数。

```
parameter = token "=" ( token / quoted-string )
```

类型、子类型和参数名称标记是不区分大小写的。参数值可能区分大小写，也可能不区分，这取决于参数名称的语义。一个参数的存在或不存在对媒体类型的处理可能是重要的，这取决于它在媒体类型注册表中的定义。

匹配标记产生式的参数值可以作为标记或在引号字符串中传输。带引号和不带引号的值是等价的。例如，下面的例子都是等价的，但为了一致性，首选第一个例子：

```
text/html;charset=utf-8
text/html;charset=UTF-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
```

Internet 媒体类型应该根据[BCP13]中定义的程序向 IANA 注册。

注意：与其他首部字段中的一些类似结构不同，媒体类型参数不允许在"="字符周围有空白（甚至是 "坏"空白）。

#### 3.1.1.2. Charset

HTTP 使用字符集名称来表示或协商文本表示的字符编码方案[RFC 6365]。一个字符集由一个不区分大小写的标记来识别。

```
charset = token
```

根据[RFC 2978]中定义的程序，字符集名称应该在 IANA "字符集"注册表（<http://www.iana.org/assignments/character-sets>）中注册。

#### 3.1.1.3. 编码和文本缺省

Internet 媒体类型被注册为标准形式，以便在具有不同本地编码格式的系统之间实现互操作。由于多用途 Internet 邮件扩展（MIME）[RFC 2045]所描述的许多相同原因，通过 HTTP 选择或传输的表示应该是典型的形式。然而，电子邮件部署的性能特征（即存储和转发报文给对等人）与 HTTP 和 Web（基于服务器的信息服务）的共同特征有很大的不同。此外，MIME 为了与旧的邮件传输协议兼容而做出的限制并不适用于 HTTP（见附录 A）。

MIME 的规范形式要求 "文本" 类型的媒体子类型使用 CRLF 作为文本换行符。HTTP 允许用普通的 CR 或 LF 单独代表换行符来传输文本媒体，当这种换行符在整个表示中是一致的。一个 HTTP 发送方 **可以** 生成，而接收方 **必须** 能够解析由 CRLF、裸 CR 或裸 LF 组成的文本媒体中的换行符。此外，HTTP 中的文本媒体并不局限于使用字节 13 和 10 的 CR 和 LF 的字符集。这种关于换行的灵活性只适用于被指定为 "文本" 媒体类型的表示中的文本；它不适用于 "multipart" 类型或有效载荷主体之外的 HTTP 元素（例如，首部字段）。

如果一个表现形式被编码为内容编码，那么底层数据在被编码之前就应该是上述定义的形式。

#### 3.1.1.4. Multipart 类型

MIME 提供了许多 "multipart"类型：在一个单一的报文体中封装一个或多个表现形式。所有 multipart 类型共享一个共同的语法，如[RFC 2046]第 5.1.1 节所定义的，并包括一个边界参数作为媒体类型值的一部分。报文体本身是一个协议元素；发送方必须只生成 CRLF 来表示报文体之间的换行。

HTTP 报文分帧不使用 multipart 边界作为报文体长度的指标，尽管它可能被生成或处理有效载荷的实现所使用。例如，"multipart/form-data" 类型通常用于在请求中携带表单数据，如[RFC 2388]所述，而 "multipart/byteranges "类型则由本规范定义，用于一些 206(Partial Content)响应[RFC 7233]。

#### 3.1.1.5. Content-Type

"Content-Type" 首部字段表示相关表示的媒体类型：要么是包含在报文有效载荷中的表示，要么是由报文语义决定的选定表示。所指示的媒体类型既定义了数据格式，也定义了在接收到的报文语义范围内，在任何由 Content-Encoding 指示的内容编码被解码之后，数据打算如何被接收方处理。

```
Content-Type = media-type
```

媒体类型在第 3.1.1.1 节中定义。该字段的一个例子是

```http
Content-Type: text/html; charset=ISO-8859-4
```

生成包含有效载荷的报文的发送方 **应该** 在该报文中生成一个 Content-Type 首部字段，除非发送方不知道所附表示的预期媒体类型。如果不存在 Content-Type 首部字段，接收方 **可以** 假定媒体类型为 "application/octet-stream"（[RFC 2046]，第 4.5.1 节）或检查数据以确定其类型。

在实践中，资源所有者并不总是正确地配置他们的源服务器，以便为给定的表示提供正确的内容类型，结果是一些客户会检查有效载荷的内容并覆盖指定的类型。这样做的客户有可能得出不正确的结论，这可能会暴露出额外的安全风险（例如，"特权升级"）。此外，不可能通过检查数据格式来确定发送方的意图：许多数据格式与多种媒体类型相匹配，只是在处理语义方面有所不同。我们鼓励实施者在使用这种 "内容嗅探" 时提供一种禁用的方法。

### 3.1.2. 压缩或完整性的编码

#### 3.1.2.1. 内容编码

内容编码(content-coding)值表示已经或可以应用于一个表示的编码转换。内容编码主要是用来让一个代表被压缩或以其他方式进行有用的转换，而不会失去其基础媒体类型的身份和信息的损失。通常情况下，表示以编码形式存储，直接传输，并只由最终的接收方解码。

```
content-coding = token
```

所有的内容编码值都是不区分大小写的，并且应该在 "HTTP 内容编码注册" 中注册，如第 8.4 节所定义。它们被用于 Accept-Encoding（第 5.3.4 节）和 Content-Encoding（第 3.1.2.2 节）首部字段。

本规范定义了以下内容编码值：

```
compress (and x-compress): 见[RFC 7230]的 4.2.1节.
deflate: 见[RFC 7230]的 4.2.2节.
gzip (and x-gzip): 见[RFC 7230]的 4.2.3节.
```

#### 3.1.2.2. Content-Encoding

"Content-Encoding" 首部字段表明，除了媒体类型中固有的内容编码外，还有哪些内容编码被应用到表示中，因此，为了获得 Content-Type 首部字段所指的媒体类型中的数据，必须应用哪些解码机制。内容编码主要是用来允许对表示的数据进行压缩而不失去其基础媒体类型的特性。

```
Content-Encoding = 1#content-coding
```

其使用的一个例子是：

```http
Content-Encoding: gzip
```

如果一个或多个编码被应用于一个表示，应用这些编码的发送方 **必须** 生成一个 Content-Encoding 首部字段，按照应用的顺序列出内容编码。关于编码参数的其他信息可以由本规范没有定义的其他首部字段提供。

与 Transfer-Encoding（[RFC 7230]第 3.3.1 节）不同，Content-Encoding 中列出的编码是表示的一个特征；表示是以编码形式定义的，所有其他关于表示的元数据都是关于编码形式的，除非在元数据定义中另外指出。通常情况下，该表示只在渲染或类似的使用之前被解码。

如果媒体类型包括一个固有的编码，例如一个总是被压缩的数据格式，那么这个编码将不会在 Content-Encoding 中重述，即使它恰好与其中一个内容编码的算法相同。这样的内容编码只有在由于某种奇怪的原因，它被第二次应用来形成表示时才会被列出。同样，一个源服务器 **可以** 选择将相同的数据发布为多种表示，而这些表示的不同之处仅在于编码是否被定义为内容类型或内容编码的一部分，因为一些用户代理在处理每个响应时会有不同的行为（例如，打开一个 "保存为... "对话框，而不是自动解压和渲染内容）。

如果请求报文中的某个表示具有不可接受的内容编码，源服务器 **可以** 用 415(Unsupported Media Type)的状态码进行响应。

### 3.1.3. 受众语言

#### 3.1.3.1. 语言标签

按照[RFC 5646]的定义，语言标签(language-tag)是指人类为了向其他人类传递信息而说、写或以其他方式传达的自然语言。计算机语言被明确地排除在外。

HTTP 在 Accept-Language 和 Content-Language 首部字段中使用语言标签。Accept-Language 使用第 5.3.5 节中定义的更广泛的语言范围产生式，而 Content-Language 使用下面定义的语言标签产生式：

```
language-tag = <Language-Tag, 见 [RFC 5646], 2.1节>
```

一个语言标签是由一个或多个不区分大小写的子标签组成的序列，每个子标签由一个连字符（"-"，%x2D）分隔。在大多数情况下，一个语言标签由一个主要的语言子标签组成，它确定了一个广泛的相关语言家族（例如，"en"=英语），后面可以选择一系列子标签，以细化或缩小该语言的范围（例如，"en-CA"=在加拿大传播的英语类型）。语言标签中不允许有空格。标签的例子包括：

```http
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

更多信息见[RFC 5646]。

#### 3.1.3.2. Content-Language

"Content-Language" 首部字段描述了该表示的预期受众的自然语言。请注意，这可能不等同于表示中使用的所有语言。

```
Content-Language = 1#language-tag
```

语言标签的定义见第 3.1.3.1 节。Content-Language 的主要目的是允许用户根据自己喜欢的语言来识别和区分表示。因此，如果内容只为懂丹麦语的读者准备，适当的字段是

```http
Content-Language: da
```

如果没有指定 Content-Language，默认为该内容是为所有语言的受众准备的。这可能意味着发送方不认为它是针对任何自然语言的，或者发送方不知道它是针对哪种语言的。

对于面向多种受众的内容，**可以** 列出多种语言。例如，"怀唐伊条约" 的演绎，同时以毛利语和英语的原始版本呈现，将要求

```http
Content-Language: mi, en
```

然而，仅仅因为一种表示中存在多种语言，并不意味着它是为多种语言的受众准备的。一个例子是初学者的语言启蒙读物，如 "拉丁语第一课"，它显然是为了给懂英语的读者使用。在这种情况下，"Content-Language" 应该只包括 "en"。

Content-Language **可以** 适用于任何媒体类型--它不限于文本文件。

### 3.1.4. 识别

#### 3.1.4.1. 识别一个表示

当一个完整的或部分的表示被传输到一个报文有效载荷中时，通常希望发送方能提供或接收方能确定与该表示相对应的资源的标识符。

对于一个请求报文：

- 如果请求有一个 Content-Location 首部字段，那么发送方就断言有效载荷是 Content-Location 字段值所确定的资源的表示。然而，这样的断言不能被信任，除非它能被其他方式验证（不是由本规范定义）。该信息对修订历史链接可能仍然有用。

- 否则，有效载荷将无法识别。

对于响应报文，按顺序应用以下规则，直到找到一个匹配的信息：

1. 如果请求方法是 GET 或 HEAD，并且响应状态码是 200(OK)、204(No Content)、206(Partial Content)或 304(Not Modified)，则有效载荷是由有效请求 URI（[RFC 7230]第 5.5 节）标识的资源的表示。

2. 如果请求方法是 GET 或 HEAD，并且响应状态码是 203(Non-Authoritative Information)，则有效载荷是由中继提供的目标资源的潜在修改或增强表示。

3. 如果响应有一个 Content-Location 首部字段，并且其字段值是对与有效请求 URI 相同的 URI 的引用，则有效载荷是有效请求 URI 所标识的资源的表示。

4. 如果响应有一个 Content-Location 首部字段，其字段值是对不同于有效请求 URI 的 URI 的引用，那么发送方断言有效载荷是 Content-Location 字段值所确定的资源的表示。然而，这样的断言不能被信任，除非它能被其他方式验证（不是由本规范定义）。

5. 否则，有效载荷将无法识别。

#### 3.1.4.2. Content-Location

"Content-Location" 首部字段引用了一个 URI，该 URI 可被用作与本报文有效载荷中的表示相对应的特定资源的标识符。换句话说，如果人们在本报文产生时对这个 URI 执行一个 GET 请求，那么一个 200(OK)的响应将包含与本报文中作为有效载荷的相同表示。

```
Content-Location = absolute-URI / partial-URI
```

Content-Location 值不是有效请求 URI 的替代物（[RFC 7230]第 5.5 节）。它是表示元数据。它的语法和语义与[RFC 2557]第 4 节中为 MIME 主体部分定义的同名首部字段相同。然而，它在 HTTP 报文中的出现对 HTTP 接收方有一些特殊的影响。

如果 Content-Location 包含在 2xx(Successful)响应报文中，并且其值（在转换为绝对形式后）指向与有效请求 URI 相同的 URI，那么接收方可以认为有效载荷是该资源在报文发起日期所示时间的当前表示。对于 GET（第 4.3.1 节）或 HEAD（第 4.3.2 节）请求，这与服务器没有提供 Content-Location 时的默认语义相同。对于像 PUT（第 4.3.4 节）或 POST（第 4.3.3 节）这样的状态改变请求，它意味着服务器的响应包含该资源的新表示，从而将其与可能只报告动作的表示区分开来（例如，"它成功了！"）。这允许编写应用程序更新他们的本地副本，而不需要后续的 GET 请求。

如果 Content-Location 包含在 2xx(Successful)响应报文中，并且其字段值指的是与有效请求 URI 不同的 URI，那么源服务器声称该 URI 是对应于所附表示的不同资源的标识。只有当两个标识符共享相同的资源所有者时，这样的声称才是可信的，而这是无法通过 HTTP 程序化地确定的。

- 对于对 GET 或 HEAD 请求的响应，这表明有效的请求 URI 指的是要进行内容协商的资源，而 Content-Location 字段值是所选表示的一个更具体的标识。

- 对于状态改变方法的 201(Created)响应，与 Location 字段值相同的 Content-Location 字段值表明该有效载荷是新创建资源的当前表示。

- 否则，这样的 Content-Location 表明该有效载荷是报告所请求的动作的状态的表示，并且相同的报告可以在给定的 URI 上获得（供将来用 GET 访问）。给定的 URI 上可以得到同样的报告（以便将来通过 GET 访问）。例如，通过 POST 请求进行的购买交易可能包括一个收据文件，作为 200（OK）响应的有效载荷；Content-Location 字段值提供了一个标识符，以便在将来检索该相同收据的副本。

在请求报文中发送 Content-Location 的用户代理说明它的值是指用户代理最初获得所附表示的内容的地方（在该用户代理进行任何修改之前）。换句话说，用户代理正在提供一个回溯链接到原始表示的来源。

在请求报文中收到 Content-Location 字段的源服务 **必须** 将该信息视为临时的请求上下文，而不是作为元数据被逐字保存为表示的一部分。源服务器 **可以** 使用该上下文来指导处理请求或将其保存为其他用途，例如在源链接或版本元数据中。然而，源服务器 **不得** 使用这种上下文信息来改变请求的语义。

例如，如果客户对协商的资源提出 PUT 请求，并且源服务器接受该 PUT（没有重定向），那么该资源的新状态应该与该 PUT 中提供的一个表示一致；Content-Location 不能被用作反向内容选择标识符的形式来更新协商的表示之一。如果用户代理想要后一种语义，它将直接对 Content-Location URI 应用 PUT。

## 3.2. 表示数据

与 HTTP 报文相关的表示数据要么作为报文的有效载荷提供，要么由报文语义和有效请求 URI 提及。表示数据的格式和编码是由表示元数据首部字段定义的。

表示数据的数据类型通过首部字段 Content-Type 和 Content-Encoding 确定。这些定义了一个两层的、有序的编码模型：

```
representation-data := Content-Encoding( Content-Type( bits ) )
```

## 3.3. 有效载荷语义

一些 HTTP 报文作为报文的 “有效载荷” 传输完整或部分表示。在某些情况下，有效载荷可能只包含相关表示的首部字段（例如，对 HEAD 的响应）或只包含表示数据的某些部分（例如，206(Partial Content) 状态码）。

请求中的有效载荷的目的由方法语义定义。例如，PUT 请求（第 4.3.4 节）的有效载荷中的表示代表目标资源的期望状态，如果请求被成功应用，而 POST 请求（第 4.3.3 节）的有效载荷中的表示代表目标资源要处理的信息。

在响应中，有效载荷的目的是由请求方法和响应状态码定义的。例如，对 GET（第 4.3.1 节）的 200(OK)响应的有效载荷代表目标资源的当前状态，这是在报文发起日期（第 7.1.1.2 节）时观察到的，而对 POST 的响应中相同状态码的有效载荷可能代表处理结果或应用处理后目标资源的新状态。带有错误状态码的响应报文通常包含代表错误状态的有效载荷，例如它描述了错误状态以及建议采取哪些下一步措施来解决它。

具体描述有效载荷而不是相关表示的首部字段被称为 “有效载荷首部字段”。由于对报文解析的影响，本规范的其他部分定义了有效载荷首部字段。

| 首部字段名        | 定义在                |
| ----------------- | --------------------- |
| Content-Length    | [RFC 7230]的 3.3.2 节 |
| Content-Range     | [RFC 7233]的 4.2 节   |
| Trailer           | [RFC 7230]的 4.4 节   |
| Transfer-Encoding | [RFC 7230]的 3.3.1 节 |

## 3.4. 内容协商

当响应传达有效载荷信息时，无论是表示成功还是错误，源服务器通常有不同的方式来表示该信息；例如，以不同的格式、语言或编码。同样，不同的用户或用户代理可能有不同的能力、特点或偏好，这可能会影响到在这些可用的表示方式中，哪种表示方式是最好的传递。出于这个原因，HTTP 提供了内容协商的机制。

本规范定义了两种可以在协议中显示的内容协商模式。"主动式"，即服务器根据用户代理声明的偏好来选择表示，以及 "被动式"协商，即服务器提供一个表示的列表供用户代理选择。内容协商的其他模式包括 "有条件的内容"，其中表示由多个部分组成，根据用户代理的参数有选择地呈现；"主动的内容"，其中表示包含一个脚本，根据用户代理的特征提出额外的（更具体的）请求；以及 "透明的内容协商"（[RFC 2295]），其中内容选择由一个中继执行。这些模式并不是相互排斥的，而且每一种模式在适用性和实用性方面都有取舍。

请注意，在所有情况下，HTTP 都不知道资源的语义。在不同的时间和不同的内容协商维度上，源服务器对请求的响应的一致性，以及因此在不同时间观察到的资源表现的 "同一性"，完全由选择或产生这些响应的实体或算法决定。HTTP 没有注意到幕后的人。

### 3.4.1. 主动协商

当用户代理在请求中发送内容协商偏好以鼓励位于服务器上的算法选择首选表示时，这被称为主动协商（又称服务器驱动的协商）。选择是基于响应的可用表示（它可能变化的维度，如语言、内容编码等）与请求中提供的各种信息相比较，包括第 5.3 节的显式协商字段和隐式特征，如客户的网络地址或用户代理字段的一部分。

当从可用的表示中进行选择的算法难以向用户代理描述时，或者当服务器希望将其 "最佳猜测" 与第一个响应一起发送给用户代理时，主动协商是有利的（如果 "最佳猜测" 对用户来说足够好，希望避免后续请求的往返延迟）。为了改进服务器的猜测，用户代理可能会发送描述其偏好的请求首部字段。

主动协商有严重的缺点：

- 服务器不可能准确地确定什么对任何给定的用户是 "最好的"，因为这需要完全了解用户代理的能力和响应的预期用途（例如，用户想在屏幕上查看还是在纸上打印？

- 让用户代理在每个请求中描述它的能力可能是非常低效的（考虑到只有一小部分的响应有多种表现形式），并且对用户的隐私有潜在的风险。

- 它使源服务器的实现和生成对请求的响应的算法复杂化；而且。

- 它限制了共享缓存的响应的可重复使用性。

用户代理不能依赖主动协商的偏好得到一致的尊重，因为源服务器可能没有为请求的资源实施主动协商，或者可能决定发送不符合用户代理偏好的响应比发送 406(Not Acceptable)响应更好。

Vary 首部字段（第 7.1.4 节）通常在受主动协商的响应中发送，以表明请求报文的哪些部分被用于选择算法。

### 3.4.2. 被动协商

通过被动协商（又称代理驱动的协商），用户代理在收到来自源服务器的初始响应后执行最佳响应表示的选择（无论状态码如何），该响应包含替代表示的资源列表。如果用户代理对初始响应表示不满意，它可以对一个或多个替代资源执行 GET 请求，这些替代资源是根据包含在列表中的元数据选择的，以获得该响应的不同表示形式。替代资源的选择可以由用户代理自动执行，或者由用户从生成的（可能是超文本）菜单中手动选择。

请注意，上面提到的是响应的表示方法，一般来说，不是资源的表示方法。只有当提供这些替代方案的响应具有作为目标资源的表示的语义（例如，对 GET 请求的 200（OK）响应）或具有为目标资源提供替代表示的链接的语义（例如，对 GET 请求的 300(Multiple Choices)响应），替代表示才被视为目标资源的表示。

服务器 **可以** 选择不发送初始表示，而不是备选方案的列表，从而表明用户代理的被动协商是首选。例如，在具有 300(Multiple Choices)和 406(Not Acceptable)状态码的响应中列出的备选方案包括关于可用的表示方法的信息，以便用户或用户代理可以通过做出选择做出反应。

当响应会在常用的维度（如类型、语言或编码）上发生变化时，当源服务器无法通过检查请求来确定用户代理的能力时，以及通常当公共缓存被用来分配服务器负载并减少网络使用时，被动协商是有利的。

被动协商有以下缺点：向用户代理传输替代方案的列表，如果在首部部分传输，会降低用户感知的延迟，并且需要第二次请求来获得替代的表示。此外，本规范没有定义支持自动选择的机制，尽管它并不妨碍将这种机制作为一种扩展来开发。

# 4. 请求方法

## 4.1. 概览

请求方法标记是请求语义的主要来源；它指出了客户提出这个请求的目的，以及客户对成功结果的期望。

请求方法的语义可以通过一些首部字段的语义在请求中出现时进一步专业化（第 5 节），如果这些额外的语义与方法不冲突的话。例如，客户可以发送有条件的请求首部字段（第 5.2 节），以使请求的动作以目标资源的当前状态为条件（[RFC 7232]）。

```
method = token
```

HTTP 最初被设计为可用作分布式对象系统的接口。请求方法被设想为在目标资源上应用语义，就像在确定的对象上调用定义的方法来应用语义一样。方法标记是区分大小写的，因为它可能被用作通往基于对象的系统的网关，而该系统的方法名称是区分大小写的。

与分布式对象不同，HTTP 中的标准化请求方法不是针对特定资源的，因为统一的接口在基于网络的系统中提供了更好的可见性和重用性[REST]。一旦被定义，标准化方法在应用于任何资源时都应该具有相同的语义，尽管每个资源自己决定这些语义是否被实现或允许。

本规范定义了一些 HTTP 中常用的标准化方法，如下表所示。按照惯例，标准化的方法是以全大写的 US-ASCII 字母来定义的。

| 方法    | 描述                                         | 章节  |
| ------- | -------------------------------------------- | ----- |
| GET     | 传输目标资源的当前表示。                     | 4.3.1 |
| HEAD    | 与 GET 相同，但只传输状态行和首部区域。      | 4.3.2 |
| POST    | 对请求有效载荷进行特定资源处理。             | 4.3.3 |
| PUT     | 用请求的有效载荷替换目标资源的所有当前表示。 | 4.3.4 |
| DELETE  | 移除目标资源的所有当前表示。                 | 4.3.5 |
| CONNECT | 建立一个隧道到目标资源所识别的服务器。       | 4.3.6 |
| OPTIONS | 描述目标资源的通信选项。                     | 4.3.7 |
| TRACE   | 沿着通往目标资源的路径进行报文回环测试。     | 4.3.8 |

所有通用服务器都必须支持 GET 和 HEAD 方法。所有其他的方法都是 **可选的**。

本规范范围之外的其他方法已经被标准化，以便在 HTTP 中使用。所有这些方法都应该在 IANA 维护的 "超文本传输协议（HTTP）方法注册表" 中注册，如第 8.1 节所定义。

目标资源所允许的方法集可以在 Allow 首部字段中列出（第 7.4.1 节）。然而，允许的方法集可以动态地改变。当收到未被源服务器识别或未被源服务器实现的请求方法时，源服务器应该以 501(Not Implemented)状态码进行响应。当接收到源服务器已知但目标资源不允许的请求方法时，源服务器应以 405(Method Not Allowed)状态码进行响应。

## 4.2. 常见方法的属性

### 4.2.1. 安全方法

如果请求方法所定义的语义基本上是只读的，则被认为是 "安全的"；也就是说，客户不要求，也不期望，由于对目标资源应用安全方法而在源服务器上产生任何状态变化。同样地，合理地使用安全方法也不会对源服务器造成任何伤害、财产损失或不寻常的负担。

这个安全方法的定义并不妨碍实现包括有潜在危害的行为，不完全是只读的，或者在调用安全方法时引起副作用。然而，重要的是，客户没有要求这种额外的行为，不能对其负责。例如，大多数服务器在每个响应完成时都会将请求信息附加到访问日志文件中，不管是什么方法，这被认为是安全的，即使日志存储可能会变满并使服务器崩溃。同样，通过选择网络上的广告发起的安全请求，往往会产生向广告账户收费的副作用。

在本规范定义的请求方法中，GET、HEAD、OPTIONS 和 TRACE 方法被定义为安全的。

区分安全和不安全方法的目的是允许自动检索过程（爬虫）和缓存性能优化（预取）工作而不用担心造成伤害。此外，它允许用户代理在处理可能不受信任的内容时对不安全方法的自动使用进行适当的限制。

当向用户展示潜在的动作时，用户代理 **应该** 区分安全和不安全的方法，这样用户就可以在请求之前了解不安全的动作。

当一个资源被构造成有效请求 URI 中的参数具有选择动作的效果时，资源所有者有责任确保该动作与请求方法的语义一致。例如，基于网络的内容编辑软件通常在查询参数中使用动作，如 "page?do=delete"。如果这种资源的目的是执行不安全的动作，那么当使用安全请求方法访问它时，资源所有者 **必须** 禁用或不允许该动作。如果不这样做，当自动程序为了维护链接、预取、建立搜索索引等而对每个 URI 引用执行 GET 时，将导致不幸的副作用。

### 4.2.2. 幂等方法

如果使用一个请求方法的多个相同的请求对服务器的影响与单个请求的影响相同，那么该请求方法被认为是 “幂等的”。在本规范所定义的请求方法中，PUT、DELETE 和 safe 请求方法是幂等的。

和安全的定义一样，同效属性只适用于用户请求的内容；服务器可以自由地单独记录每个请求，保留修订控制历史，或者为每个同位素请求实现其他非同位素的副作用。

幂等方法的区别在于，如果在客户能够读取服务器的响应之前发生通信故障，请求可以自动重复。例如，如果一个客户发送了一个 PUT 请求，而底层连接在收到任何响应之前就被关闭了，那么客户可以建立一个新的连接并重试该同效请求。它知道重复请求将产生相同的预期效果，即使最初的请求成功了，尽管响应可能不同。

### 4.2.3. 可缓存方法

请求方法可以被定义为 "可缓存的"，以表明对它们的响应允许被存储以便将来重复使用；具体要求见[RFC 7234] 。一般来说，不依赖于当前或权威响应的安全方法被定义为可缓存；本规范将 GET、HEAD 和 POST 定义为可缓存，尽管绝大多数的缓存实现只支持 GET 和 HEAD。

## 4.3. 方法定义

### 4.3.1. GET

GET 方法要求为目标资源传输当前选定的表示。GET 是信息检索的主要机制，也是几乎所有性能优化的重点。因此，当人们谈到通过 HTTP 检索一些可识别的信息时，他们一般指的是提出一个 GET 请求。

我们很容易把资源标识符看作是远程文件系统的路径名，而把表示看作是这种文件内容的副本。事实上，许多资源就是这样实现的（相关的安全考虑见第 9.1 节）。然而，在实践中并没有这种限制。一个资源的 HTTP 接口同样有可能被实现为一棵内容对象的树，一个关于各种数据库记录的程序性视图，或者一个通往其他信息系统的网关。即使当 URI 映射机制与文件系统挂钩时，源服务器也可能被配置为以请求为输入执行文件，并将输出作为表示发送，而不是直接传输文件。无论如何，只有源服务器需要知道它的每个资源标识符如何对应于一个实现，以及每个实现如何管理选择并在对 GET 的响应中发送目标资源的当前表示。

客户可以改变 GET 的语义，使其成为一个 "范围请求"，通过在请求中发送一个范围首部字段，只请求传输所选表示的某些部分（[RFC 7233]）。

GET 请求报文中的有效载荷没有定义语义；在 GET 请求中发送有效载荷可能导致一些现有的实现拒绝该请求。

对 GET 请求的响应是可缓存的；除非 Cache-Control 首部字段另有说明，否则缓存 **可以** 使用它来满足后续的 GET 和 HEAD 请求（[RFC 7234]的第 5.2 节）。

### 4.3.2. HEAD

HEAD 方法与 GET 相同，除了服务器必须不在响应中发送报文体（即响应在首部部分结束时终止）。服务器在响应 HEAD 请求时应该发送与请求是 GET 时相同的首部字段，除了有效载荷首部字段（第 3.3 节）可能被省略。这种方法可以用来获取关于所选表示的元数据，而不需要传输表示数据，并且经常被用来测试超文本链接的有效性、可访问性和最近的修改。

HEAD 请求报文中的有效载荷没有定义语义；在 HEAD 请求中发送有效载荷可能导致一些现有的实现拒绝该请求。

对 HEAD 请求的响应是可缓存的；除非由 Cache-Control 首部字段（[RFC 7234]第 5.2 节）另行说明，否则缓存 **可以** 使用它来满足后续的 HEAD 请求。HEAD 响应也可能对先前缓存的 GET 响应产生影响；见 [RFC 7234] 的第 4.3.5 节。

### 4.3.3. POST

POST 方法要求目标资源根据资源自身的特定语义来处理请求中所包含的表示。例如，POST 被用于以下功能（除其他外）。

- 提供一个数据块，如输入 HTML 表格的字段，给一个数据处理过程。
- 向公告板、新闻组、邮件列表、博客或类似的文章组发布消息。
- 创建一个尚未被源服务器识别的新资源；以及
- 将数据添加到资源的现有表示上。

源服务器根据 POST 请求的处理结果选择适当的状态码来表示响应语义；本规范定义的几乎所有状态码都可能在 POST 的响应中被收到（例外是 206(Partial Content), 304 (Not Modified) 和 416 (Range Not Satisfiable)）。

如果由于成功地处理了 POST 请求而在源服务器上创建了一个或多个资源，那么源服务器 **应该** 发送一个 201(Created)响应，其中包含一个 Location 首部字段，该首部字段提供了所创建的主要资源的标识符（第 7.1.2 节）和描述请求状态的表示，同时提到了新资源。

对 POST 请求的响应只有在包含明确的新鲜度报文时才是可缓存的（见[RFC 7234]第 4.2.1 节）。然而，POST 缓存并没有被广泛实施。对于源服务器希望客户能够以可被后来的 GET 重用的方式缓存 POST 的结果的情况，源服务器 **可以** 发送一个 200(OK)响应，其中包含结果和一个 Content-Location 首部字段，其值与 POST 的有效请求 URI 相同（3.1.4.2 节）。

如果处理 POST 的结果等同于现有资源的表示，源服务器 **可以** 通过发送 303(See Other)响应将用户代理重定向到该资源，在 Location 字段中包含现有资源的标识。这样做的好处是为用户代理提供一个资源标识符，并通过一个更适合共享缓存的方法来传输表示，不过如果用户代理还没有缓存表示，则要付出额外的请求。

### 4.3.4. PUT

PUT 方法要求目标资源的状态被创建或替换为请求报文有效载荷中所包含的表示所定义的状态。对一个给定表示的成功 PUT 将表明，对同一目标资源的后续 GET 将导致在 200(OK)响应中发送一个相等的表示。然而，不能保证这样的状态变化是可以观察到的，因为目标资源可能被其他用户代理并行操作，或者在收到任何后续的 GET 之前，可能被源服务器动态处理。一个成功的响应只意味着用户代理的意图在被源服务器处理的时候已经实现。

如果目标资源没有当前的表示，而 PUT 成功地创建了一个表示，那么源服务器 **必须** 通过发送 201(Created)响应来通知用户代理。如果目标资源确实有一个当前的表示，并且该表示被成功地按照所包围的表示的状态进行了修改，那么源服务器 **必须** 发送一个 200(OK)或 204(No Content)的响应来表示请求的成功完成。

源服务器 **应该** 忽略在 PUT 请求中收到的未识别的首部字段（即，不把它们保存为资源状态的一部分）。

源服务器 **应该** 验证 PUT 表示与服务器对目标资源的任何约束一致，这些约束不能或不会被 PUT 所改变。当源服务器使用与 URI 有关的内部配置信息来设置 GET 响应的表示元数据的值时，这一点尤其重要。当 PUT 表示与目标资源不一致时，源服务器 **应该** 通过转换表示或改变资源配置来使它们一致，或者用适当的错误消息来响应，其中包含足够的信息来解释为什么表示不适合。建议使用 409(Conflict)或 415(Unsupported Media Type)状态码，后者是专门针对内容类型值的约束。

例如，如果目标资源被配置为总是具有 "text/html" 的内容类型，而被 PUT 的表述具有 "image/jpeg" 的内容类型，源服务器应该采取以下措施之一。

a. 重新配置目标资源以反映新的媒体类型。
b. 将 PUT 的表述转换为与资源的格式一致的格式。
b. 在将其保存为新的资源状态之前，将 PUT 表示法转换为与资源的格式一致；或者。
c. 用 415（不支持的媒体类型）响应拒绝请求，表明目标资源仅限于 "text/html"，也许包括一个指向不同资源的链接，该资源将成为新表示的合适目标。

除了用户代理请求的意图和源服务器响应的语义所能表达的之外，HTTP 并没有确切地定义 PUT 方法如何影响源服务器的状态。除了通过 HTTP 提供的接口之外，它并没有定义资源在任何意义上可能是什么。它没有定义资源状态如何被 "存储"，也没有定义这种存储如何因资源状态的变化而变化，更没有定义源服务器如何将资源状态转化为表示。一般来说，资源接口背后的所有实现细节都被服务器有意隐藏。

源服务器 **不得** 在对 PUT 的成功响应中发送验证器首部字段（第 7.2 节），如 ETag 或 Last-Modified 字段，除非请求的表示数据在没有对主体进行任何转换的情况下被保存（即，资源的新表示数据与 PUT 请求中收到的表示数据相同），并且验证器字段值反映了新的表示。这一要求允许用户代理知道，由于 PUT 的结果，它在内存中的表示仍然是最新的，因此不需要再从源服务器中检索，并且在响应中收到的新验证器可以用于未来的条件请求，以防止意外的覆盖（第 5.2 节）。

POST 和 PUT 方法之间的根本区别突出表现在对所附表示的不同意图上。POST 请求中的目标资源旨在根据资源自身的语义来处理封闭的表示，而 PUT 请求中的封闭表示被定义为替换目标资源的状态。因此，PUT 的意图是空闲的，对中继来说是可见的，尽管确切的效果只有源服务器知道。

对 PUT 请求的正确解释假定用户代理知道想要哪个目标资源。在收到状态改变的请求后，代表客户选择适当的 URI 的服务应该使用 POST 方法而不是 PUT 来实现。如果源服务器不会对目标资源进行请求的 PUT 状态改变，而是希望将其应用于不同的资源，例如当资源被移动到不同的 URI 时，那么源服务器必须发送一个适当的 3xx(Redirection)响应；然后用户代理可以自己决定是否重定向请求。

应用于目标资源的 PUT 请求可以对其他资源产生副作用。例如，一篇文章可能有一个识别 "当前版本"（一个资源）的 URI，它与识别每个特定版本的 URI 是分开的（不同的资源在某一时刻与当前版本资源共享同一状态）。因此，在 "当前版本" URI 上成功的 PUT 请求除了改变目标资源的状态外，还可能创建一个新的版本资源，并可能导致相关资源之间增加链接。

允许在给定的目标资源上进行 PUT 的源服务器必须对包含 Content-Range 首部字段的 PUT 请求发送 400(Bad Request)响应（[RFC 7233]第 4.2 节），因为有效载荷可能是部分内容，被误认为是完整的表述而 PUT。部分内容的更新可以通过针对一个单独识别的资源，其状态与大资源的一部分重叠，或者通过使用专门为部分更新定义的不同方法（例如，[RFC 5789]中定义的 PATCH 方法）。

对 PUT 方法的响应是不可缓存的。如果一个成功的 PUT 请求通过有一个或多个针对有效请求 URI 的存储响应的缓存，这些存储响应将被废止（见[RFC 7234]第 4.4 节）。

### 4.3.5. DELETE

DELETE 方法要求源服务器删除目标资源和其当前功能之间的关联。功能之间的联系。实际上，这个方法类似于 UNIX 中的 rm 命令：它表达了对源服务器的 URI 映射的删除操作，而不是期望删除先前关联的信息。

如果目标资源有一个或多个当前表示，它们可能被源服务器销毁，也可能不被销毁，相关的存储可能被回收，也可能不被回收，这完全取决于资源的性质和源服务器的实现（这不在本规范的范围之内）。同样，资源的其他实现方面可能需要作为 DELETE 的结果被停用或归档，例如数据库或网关连接。一般来说，我们假设源服务器只允许对它有规定的机制来完成删除的资源进行 DELETE。

允许 DELETE 方法的资源相对较少：其主要用途是在远程创作环境中，用户对其效果有一些指导。例如，先前使用 PUT 请求创建的资源，或通过 201(Created)响应 POST 请求后的 Location 首部字段识别的资源，可能允许相应的 DELETE 请求来撤销这些操作。同样地，实现编写功能的自定义用户代理实现，如使用 HTTP 进行远程操作的修订控制客户，可能会根据服务器的 URI 空间已被精心设计为对应于版本库的假设，使用 DELETE。

如果 DELETE 方法被成功应用，如果动作可能成功但尚未实施，源服务器应该发送 202(Accepted)状态码；如果动作已经实施并且没有进一步的信息需要提供，则发送 204(No Content)状态码；如果动作已经实施并且响应报文包括描述状态的表示，则发送 200(OK)状态码。

在 DELETE 请求报文中的有效载荷没有定义语义；在 DELETE 请求中发送有效载荷可能导致一些现有的实现拒绝该请求。

对 DELETE 方法的响应是不可缓存的。如果一个 DELETE 请求通过一个有一个或多个针对有效请求 URI 的存储响应的缓存，这些存储的响应将被废止（见[RFC 7234]的第 4.4 节）。

### 4.3.6. CONNECT

CONNECT 方法要求接收方建立一个隧道到由请求-目标确定的目标源服务器，如果成功，此后限制其行为，在两个方向上盲目转发数据包，直到隧道关闭。隧道通常用于创建一个端到端的虚拟连接，通过一个或多个代理，然后可以使用 TLS（传输层安全，[RFC 5246]）来保证安全。

CONNECT 只用于向代理发出的请求。收到为自己发出的 CONNECT 请求的源服务器 **可以** 用 2xx(Successful)状态码进行响应，以表明连接已经建立。然而，大多数源服务器并没有实现 CONNECT。

发送 CONNECT 请求的客户 **必须** 发送权威形式的 request-target（[RFC 7230]第 5.3 节）；也就是说，request-target 仅由隧道目的地的主机名和端口号组成，用冒号隔开。例如

``http
CONNECT server.example.com:80 HTTP/1.1
Host：server.example.com:80

```

接收方代理 **可以** 通过直接连接到请求目标，或者如果配置为使用其他代理，则通过将CONNECT请求转发给下一个入站代理来建立隧道。任何2xx (Successful)响应表明，发送方（和所有入站代理）将在成功响应的首部部分结束的空行后立即切换到隧道模式；在该空行后收到的数据来自请求-目标所确定的服务器。任何非成功响应都表明隧道尚未形成，连接仍由HTTP管理。

当隧道中继检测到任何一方关闭了它的连接时，隧道就关闭了：中继 **必须** 尝试将任何来自关闭一方的未完成的数据发送到另一方，关闭两个连接，然后丢弃任何剩余的未交付的数据。

代理认证可能被用来建立创建隧道的权力。例如。

``http
CONNECT server.example.com:80 HTTP/1.1
Host：server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

建立通往任意服务器的隧道有很大的风险，特别是当目的地是一个众所周知的或保留的 TCP 端口，而该端口并不打算用于 Web 流量。例如，CONNECT 到 "example.com:25" 的请求目标会建议代理连接到为 SMTP 流量保留的端口；如果允许，这可能会欺骗代理转发垃圾邮件。支持 CONNECT 的代理应将其使用限制在有限的已知端口或可配置的安全请求目标白名单上。

在对 CONNECT 的 2xx(Successful)响应中，服务器 **不得** 发送任何 Transfer-Encoding 或 Content-Length 首部字段。客户 **必须** 忽略在对 CONNECT 的成功响应中收到的任何 Content-Length 或 Transfer-Encoding 标首部字段。

CONNECT 请求报文中的有效载荷没有定义语义；在 CONNECT 请求中发送有效载荷可能会导致一些现有的实现拒绝该请求。

对 CONNECT 方法的响应是不可缓存的。

### 4.3.7. OPTIONS

OPTIONS 方法请求关于目标资源可用的通信选项的信息，这些信息在源服务器或介入的中继处。这种方法允许客户确定与资源相关的选项和/或要求，或服务器的能力，而不意味着资源动作。

以星号（"\_"）作为请求目标的 OPTIONS 请求（[RFC 7230] 第 5.3 节）适用于一般的服务器而不是特定的资源。由于服务器的通信选项通常取决于资源，"\_"请求只作为一种 "ping "或 "no-op" 类型的方法有用；它除了允许客户测试服务器的能力外，没有任何作用。例如，它可以用来测试一个代理是否符合 HTTP/1.1 标准（或不符合）。

如果请求-目标不是星号，OPTIONS 请求适用于与目标资源通信时可用的选项。

生成对 OPTIONS 的成功响应的服务器 **应该** 发送可能表明由服务器实现并适用于目标资源的可选功能（例如 Allow）的任何首部字段，包括本规范没有定义的潜在扩展。响应的有效载荷（如果有的话）也可能以机器或人类可读的方式描述通信选项。本规范没有定义这种表示方法的标准格式，但可能由 HTTP 的未来扩展来定义。如果在响应中不发送有效载荷，服务器 **必须** 生成一个值为 "0" 的 Content-Length 字段。

客户 **可以** 在 OPTIONS 请求中发送一个 Max-Forwards 首部字段，以便在请求链中针对特定的接收方（见第 5.1.2 节）。代理在转发请求时 **不得** 生成 Max-Forwards 首部字段，除非该请求被接收时有 Max-Forwards 字段。

生成包含有效负载的 OPTIONS 请求的客户 **必须** 发送描述表示媒体类型的有效的 Content-Type 首部字段。尽管本规范没有定义这种有效载荷的任何用途，但未来对 HTTP 的扩展可能会使用 OPTIONS 体来对目标资源进行更详细的查询。

对 OPTIONS 方法的响应是不可缓存的。

### 4.3.8. TRACE

TRACE 方法要求对请求报文进行远程、应用级的回环。请求的最终接收方应该将收到的报文（不包括下面描述的一些字段）作为 200(OK)响应的报文体反映给客户，其内容类型为 "message/http"（[RFC 7230]第 8.3.1 节）。最终的接收方是源服务器或在请求中收到最大转发值为零（0）的第一个服务器（第 5.1.2 节）。

客户 **不得** 在 TRACE 请求中生成含有可能被响应披露的敏感数据的首部字段。例如，用户代理在 TRACE 请求中发送存储的用户凭证[RFC 7235]或 cookies[RFC 6265]是愚蠢的。请求的最终接收方在生成响应体时 **应该** 排除任何可能包含敏感数据的请求首部字段。

TRACE 允许客户看到在请求链的另一端收到的内容，并将这些数据用于测试或诊断信息。Via 首部字段的值（[RFC 7230]第 5.7.1 节）特别令人感兴趣，因为它可以作为请求链的跟踪。使用 Max-Forwards 首部字段允许客户限制请求链的长度，这对于测试无限循环转发报文的代理链很有用。

客户 **必须** 不在 TRACE 请求中发送报文体。

对 TRACE 方法的响应是不可缓存的。

# 5. 请求首部字段

客户发送请求首部字段以提供更多关于请求上下文的信息，根据目标资源状态使请求成为有条件的，建议响应的首选格式，提供认证凭证，或修改预期的请求处理。这些字段充当请求修饰字段，类似于编程语言方法调用的参数。

## 5.1. 控制

控制字段是请求首部字段，指导对请求的具体处理。

| 字段名        | 定义在               |
| ------------- | -------------------- |
| Cache-Control | [RFC 7234] 的 5.2 节 |
| Expect        | 5.1.1 节             |
| Host          | [RFC 7230]的 5.4 节  |
| Max-Forwards  | 5.1.2 节             |
| Pragma        | [RFC 7234]的 5.4 节  |
| Range         | [RFC 7233]的 3.1 节  |
| TE            | [RFC 7230]的 4.3 节  |

### 5.1.1. Expect

请求中的 "Expect"首部字段表示一组行为（期望），这些行为需要由服务器支持，以便正确处理这个请求。本规范所定义的唯一期望是 100-continue。

```
Expect = "100-continue"
```

Expect 字段值是不区分大小写的。

服务器如果收到除 100-continue 以外的 Expect 字段值，可以用 417(Expectation Failed)状态码响应，以表明不能满足这个意外的期望。

100-continue 期望通知接收方，如果请求行和首部字段不足以导致立即的成功、重定向或错误响应，则客户将在此请求中发送一个（可能是大的）报文体，并希望收到一个 100(Continue)的临时响应。这允许客户在实际发送之前等待值得发送报文体的指示，这可以在报文体很大或客户预计可能出错时提高效率（例如，当第一次发送一个状态改变的方法时，没有先前验证的认证凭证）。

例如，一个请求的开首部是

```http
PUT /somewhere/fun HTTP/1.1
Host：origin.example.com
Content-Type：video/h264
Content-Length：1234567890987
Expect: 100-continue

```

允许源服务器在客户开始用不必要的数据传输填充流水线之前，立即用一个错误信息来回应，如 401(Unauthorized)或 405(Method Not Allowed)。

对客户的要求：

- 客户不得在不包括报文体的请求中产生 100-continue 的期望。

- 在发送请求报文体之前，将等待 100(Continue)响应的客户必须发送一个包含 100-continue 期望的 Expect 首部字段。

- 发送 100-continue 期望的客户不需要等待任何特定的时间长度；这样的客户即使还没有收到响应，也可以继续发送报文体。此外，由于 100(Continue)响应不能通过 HTTP/1.0 中继发送，这样的客户不应该在发送报文体之前无限期地等待。

- 一个客户如果在响应包含 100-continue 的请求时收到 417(Expect Failed)状态码，应该重复该请求而不使用 100-continue，因为 417 响应仅仅表明响应链不支持期望（例如，它通过了 HTTP/1.0 服务器）。

对服务器的要求：

- 一个在 HTTP/1.0 请求中收到 100-continue 期望的服务器必须忽略该期望。

- 如果一个服务器已经收到了相应请求的部分或全部报文体，或者如果框架表明没有报文体，那么它可以省略发送 100(Continue)响应。

- 发送 100(Continue)响应的服务器在收到并处理了报文体后，必须最终发送一个最终状态码，除非连接被提前关闭。

- 在读取整个报文体之前就以最终状态码进行响应的服务器应该在该响应中表明它是否打算关闭连接或继续读取并丢弃请求报文（参见[RFC 7230]第 6.6 节）。

源服务器在收到 HTTP/1.1（或更高版本）请求行和包含 100-Continue 期望并表明后续将有请求报文体的完整首部文件时，必须立即发送带有最终状态码的响应，如果该状态可以通过检查请求行和首部文件字段来确定，或者立即发送 100(Continue)响应以鼓励客户发送请求的报文体。源服务器在发送 100(Continue)响应之前不应等待报文体。

代理必须在收到 HTTP/1.1(或更高版本)请求行和包含 100-Continue 期望的完整的首部信息部分，并表明请求报文体将随之而来，要么立即发送一个带有最终状态码的响应，如果该状态可以通过检查请求行和首部信息字段来确定，要么开始将请求转发给源服务器，发送一个相应的请求行和标首部部分发送到下一个入站服务器。如果代理认为（从配置或过去的交互中）下一个入站服务器只支持 HTTP/1.0，代理可能会立即生成一个 100(Continue)响应，以鼓励客户开始发送报文体。

注意：Expect 首部字段是在 HTTP/1.1[RFC 2068]最初发布后加入的，既是请求临时 100(Continue)响应的手段，也是表示必须理解的扩展的一般机制。然而，扩展机制并没有被客户使用，而且必须理解的要求也没有被许多服务器实现，这使得扩展机制变得毫无用处。本规范删除了扩展机制，以简化 100-continue 的定义和处理。

### 5.1.2. Max-Forwards

"Max-Forwards" 首部字段为 TRACE（第 4.3.8 节）和 OPTIONS（第 4.3.7 节）请求方法提供了一种机制，以限制请求被代理转发的次数。当客户试图追踪一个似乎失败或在链中循环的请求时，这可能很有用。

```
Max-Forwards = 1*DIGIT
```

Max-Forwards 值是一个十进制的整数，表示这个请求信息可以被转发的剩余次数。

每个收到包含 Max-Forwards 首部字段的 TRACE 或 OPTIONS 请求的中继 **必须** 在转发请求之前检查并更新其值。如果收到的值是零（0），中继 **必须** 不转发该请求；相反，中继 **必须** 作为最终接收方作出响应。如果收到的 Max-Forwards 值大于 0，中继 **必须** 在转发的消息中生成一个更新的 Max-Forwards 字段，其字段值为：a）收到的值减去一（1）或 b）接收方支持的 Max-Forwards 的最大值，两者中较小者。

接收方 **可以** 忽略以任何其他请求方法收到的 Max-Forwards 首部字段。

## 5.2. 条件

HTTP 条件请求首部字段[RFC 7232]允许客户在目标资源的状态上设置一个前提条件，这样，如果前提条件被评估为错误，那么对应于方法语义的操作将不会被应用。本规范定义的每个前提条件包括从目标资源的先前表示中获得的一组验证器与所选表示的验证器的当前状态之间的比较（第 7.2 节）。因此，这些先决条件评估目标资源的状态在客户已知的给定状态后是否发生了变化。这种评估的效果取决于方法语义和条件的选择，如[RFC 7232]第 5 节中所定义。

| 首部字段名          | 定义在               |
| ------------------- | -------------------- |
| If-Match            | [RFC 7232]的 3.1 节  |
| If-None-Match       | [RFC 7232]的 3.2 节  |
| If-Modified-Since   | [RFC 7232] 的 3.3 节 |
| If-Unmodified-Since | [RFC 7232] 的 3.4 节 |
| If-Range            | [RFC 7233]的 3.2 节  |

## 5.3. 内容协商

以下请求首部字段是由用户代理发送的，以便对响应内容进行主动协商，这在第 3.4.1 节中有所定义。在这些字段中发送的偏好适用于响应中的任何内容，包括目标资源的表示、错误或处理状态的表示，甚至可能包括可能出现在协议中的各种文本字符串。

| 首部字段名      | 定义在   |
| --------------- | -------- |
| Accept          | 5.3.2 节 |
| Accept-Charset  | 5.3.3 节 |
| Accept-Encoding | 5.3.4 节 |
| Accept-Language | 5.3.5 节 |

### 5.3.1. 质量值

许多用于主动协商的请求首部字段使用一个共同的参数，名为 "q"（不区分大小写），为相关种类的内容的偏好分配一个相对 "权重"。这个权重被称为 "质量值"（或 "q 值"），因为在服务器配置中经常使用相同的参数名称，为可选择资源的各种表现形式的相对质量值分配权重。

该权重被规范化为 0 到 1 范围内的一个实数，其中 0.001 是最不受欢迎的，1 是最受欢迎的；0 的值意味着 "不可接受"。如果没有 "q" 参数，默认权重为 1。

q 值的发送者不得在小数点后产生超过三位的数字。用户对这些值的配置应该以同样的方式进行限制。

### 5.3.2. Accept

用户代理可以使用 "Accept" 首部字段来指定可接受的响应媒体类型。接受首部字段可以用来表示请求被特别限制在一小部分所需的类型上，如对在线图像的请求。

```
Accept = #( media-range [ accept-params ] )

media-range = ( "*/*"
              / ( type "/" "*" )
              / ( type "/" subtype )
              ) *( OWS ";" OWS parameter )
accept-params = weight *( accept-ext )
accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
```

星号"\_"字符用于将媒体类型归入范围，"_/_"表示所有媒体类型，"type/\_"表示该类型的所有子类型。媒体范围可以包括适用于该范围的媒体类型参数。

每个媒体范围后面可能有零个或更多适用的媒体类型参数（例如，字符集），一个可选的 "q "参数，用于指示相对权重（第 5.3.1 节），然后是零个或更多的扩展参数。如果存在任何扩展参数（accept-ext），"q "参数是必要的，因为它是两个参数集之间的分隔符。

注意：使用 "q "参数名将媒体类型参数与接受扩展参数分开是出于历史惯例。尽管这可以防止任何名为 "q "的媒体类型参数被用于媒体范围，但考虑到 IANA 媒体类型注册表中没有任何 "q "参数，以及在 Accept 中很少使用任何媒体类型参数，相信这种情况不太可能发生。我们不鼓励未来的媒体类型注册任何名为 "q "的参数。

这个例子

```http
Accept: audio/*; q=0.2, audio/basic
```

被解释为 "我更喜欢 audio/basic，但如果它是质量下降 80%后的最好的音频类型，可以发给我"。

一个没有任何 Accept 首部字段的请求意味着用户代理将接受响应中的任何媒体类型。如果请求中存在首部字段，而响应的可用表述中没有一个媒体类型被列为可接受的，源服务器可以通过发送 406（不可接受）响应来尊重首部字段，或者通过将响应视为不受内容协商约束来无视首部字段。

一个更详细的例子是

```http
Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
```

在口头上，这将被解释为 "text/html 和 text/x-c 是同等优先的媒体类型，但如果它们不存在，则发送 text/x-dvi 表示，如果不存在，则发送 text/plain 表示"。

媒体范围可以被更具体的媒体范围或具体的媒体类型所覆盖。如果有一个以上的媒体范围适用于一个给定的类型，那么最具体的引用具有优先权。例如。

```http
Accept: text/*, text/plain, text/plain;format=flowed, */*
```

有以下优先权：

1. text/plain;format=flowed
2. text/plain
3. text/\*
4. \*/\*

与一个给定类型相关的媒体类型质量系数是通过找到与该类型匹配的具有最高优先级的媒体范围来确定的。比如说，

```http
Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5
```

将导致以下数值的关联：

| 媒体类型          | 质量值 |
| ----------------- | ------ |
| text/html;level=1 | 1      |
| text/html         | 0.7    |
| text/plain        | 0.3    |
| image/jpeg        | 0.5    |
| text/html;level=2 | 0.4    |
| text/html;level=3 | 0.7    |

注意：一个用户代理可能会被提供给某些媒体范围的默认质量值集。然而，除非用户代理是一个封闭的系统，不能与其他渲染代理进行交互，否则这套默认值应该是可以由用户配置的。

### 5.3.3. Accept-Charset

用户代理可以发送 "Accept-Charset" 首部字段，以表明在文本响应内容中可以接受哪些字符集。这个字段允许能够理解更全面或特殊用途的字符集的用户代理向能够以这些字符集表示信息的源服务器发出这种能力。

```
Accept-Charset = 1#( ( charset / "*" ) [ weight ] )
```

字符集名称在第 3.1.1.2 节中定义。用户代理可以将一个质量值与每个字符集联系起来，以表明用户对该字符集的相对偏好，如第 5.3.1 节所定义。一个例子是

```http
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

特殊值"\*"，如果存在于 Accept-Charset 字段中，则与 Accept-Charset 字段中未提及的每个字符集相匹配。如果 Accept-Charset 字段中没有 "\*"，那么该字段中没有明确提到的任何字符集都被认为是客户 "不可接受 "的。

一个没有任何 Accept-Charset 首部字段的请求意味着用户代理将接受任何响应的字符集。大多数通用的用户代理不发送 Accept-Charset，除非特别配置成这样，因为支持的字符集的详细列表使服务器更容易凭借用户代理的请求特征来识别一个人（第 9.7 节）。

如果请求中存在 Accept-Charset 首部字段，而响应的可用表示中没有一个字符集被列为可接受的字符集，那么源服务器可以通过发送 406（不可接受）响应来尊重该首部字段，或者通过将资源视为不受内容协商影响来忽略该首部字段。

### 5.3.4. Accept-Encoding

用户代理可以使用 "Accept-Encoding" 首部字段来表明响应中可以接受哪些响应内容编码（第 3.1.2.1 节）。一个 "identity" 标记被用作 "无编码" 的同义词，以便在无编码时进行交流。

```
Accept-Encoding = #( codings [ weight ] )
codings = content-coding / "identity" / "*"
```

每个编码值可能被赋予一个相关的质量值，代表对该编码的偏好，定义在第 5.3.1 节。在 Accept-Encoding 字段中的星号 "\*"与任何没有明确列在首部字段中的可用内容编码相匹配。

例如。

```http
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
```

一个没有 Accept-Encoding 首部字段的请求意味着用户代理对内容编码没有偏好。虽然这允许服务器在响应中使用任何内容编码，但这并不意味着用户代理能够正确处理所有的编码。

服务器使用这些规则来测试一个给定表示的内容编码是否可以接受。

1. 如果请求中没有 Accept-Encoding 字段，任何内容编码都被用户代理认为是可以接受的。

2. 如果表示没有内容编码，那么默认情况下是可以接受的，除非被 Accept-Encoding 字段特别排除。
   Accept-Encoding 字段说明 "identity;q=0 "或 "\*;q=0 "而没有更具体的 "identity "条目，则默认为可接受。

3. 如果表示的内容编码是 Accept-Encoding 字段中列出的内容编码之一，那么它是可以接受的，除非它伴随着一个 0 的 q 值。

4. 如果多个内容编码是可接受的，那么具有最高非零 q 值的可接受内容编码是首选。

一个 Accept-Encoding 首部字段的组合字段值为空，意味着用户代理不希望有任何内容编码的响应。如果在一个请求中存在一个 Accept-Encoding 首部字段，并且没有一个可用的响应代表有一个被列为可接受的内容编码，源服务器应该发送一个没有任何内容编码的响应。

注意：大多数 HTTP/1.0 应用程序不承认或服从与内容编码相关的 qvalues。这意味着 q 值可能不起作用，并且不允许使用 x-gzip 或 x-compress。

### 5.3.5. Accept-Language

用户代理可以使用 "Accept-Language" 首部字段来表明响应中首选的自然语言集。语言标签的定义见第 3.1.3.1 节。

```
Accept-Language = 1#( language-range [ weight ] )
language-range = <language-range, 见 [RFC 4647], 2.1节>
```

每个语言范围可以被赋予一个相关的质量值，代表对用户对该范围所规定的语言的偏好的估计，如第 5.3.1 节所定义。比如说，

```http
Accept-Language: da, en-gb;q=0.8, en;q=0.7
```

将意味着 "我喜欢丹麦语，但也接受英国英语和其他类型的英语"。

一个没有任何 Accept-Language 首部字段的请求意味着用户代理将接受任何语言的响应。如果请求中存在该首部字段，而响应的可用表述中没有一个匹配的语言标签，源服务器可以通过将响应视为不受内容协商影响来忽略该首部字段，或者通过发送 406（不可接受）响应来尊重该首部字段。然而，我们不鼓励后者，因为这样做会阻止用户访问他们可能会使用的内容（例如，使用翻译软件）。

请注意，一些接收方将语言标签的排列顺序视为优先级递减的标志，特别是对于那些被分配了相同质量值的标签（没有值与 q=1 相同）。然而，这种行为是不能依赖的。为了一致性和最大限度地提高互操作性，许多用户代理为每个语言标签分配一个独特的质量值，同时也按质量递减的顺序列出。关于语言优先级列表的其他讨论可以在[RFC 4647]第 2.3 节中找到。

对于匹配，[RFC 4647]的第 3 节定义了几种匹配方案。实现者可以根据他们的要求提供最合适的匹配方案。"基本过滤" 方案（[RFC 4647]，第 3.3.1 节）与先前在 [RFC 2616] 第 14.4 节中为 HTTP 定义的匹配方案相同。

在每个请求中发送一个带有用户完整语言偏好的 Accept-Language 首部字段（第 9.7 节）可能有悖于用户的隐私期望。

由于可理解性在很大程度上取决于个人用户，用户代理需要允许用户控制语言偏好（通过用户代理本身的配置或默认为用户可控制的系统设置）。不向用户提供这种控制的用户代理必须不发送 Accept-Language 首部字段。

注意：用户代理应该在设置偏好时向用户提供指导，因为用户很少熟悉上述语言匹配的细节。例如，用户可能认为在选择 "en-gb "时，如果没有英式英语，他们将被提供任何种类的英语文件。在这种情况下，用户代理可能会建议将 "en "添加到列表中以获得更好的匹配行为。

## 5.4. 认证凭据

如[RFC 7235]所定义，有两个首部字段用于携带认证凭据。请注意，各种自定义的用户认证机制为此目的使用 Cookie 首部字段，如[RFC 6265]所定义。

| 首部字段名          | 定义在               |
| ------------------- | -------------------- |
| Authorization       | [RFC 7235] 的 4.2 节 |
| Proxy-Authorization | [RFC 7235] 的 4.4 节 |

## 5.5. 请求上下文

以下请求首部字段提供了关于请求上下文的额外信息，包括关于用户、用户代理和请求背后的资源的信息。

| 首部字段名 | 定义在   |
| ---------- | -------- |
| From       | 5.5.1 节 |
| Referer    | 5.5.2 节 |
| User-Agent | 5.5.3 节 |

### 5.5.1. From

"From" 首部字段包含一个控制请求用户代理的人类用户的互联网电子邮件地址。该地址应该是机器可使用的，如[RFC 5322]第 3.4 节的 "mailbox" 所定义。

```
From = mailbox
mailbox = <mailbox, 见 [RFC5322], 3.4节>
```

一个例子是:

```http
From: webmaster@example.org
```

非机器人用户代理很少发送 "From" 首部字段。用户代理 **不应该** 在没有用户明确配置的情况下发送 From 字段，因为这可能与用户的隐私利益或他们网站的安全政策相冲突。

机器人用户代理 **应该** 发送一个有效的 From 字段，以便在服务器出现问题时，例如机器人发送过多的、不需要的或无效的请求时，可以联系到负责运行机器人的人。

服务器 **不应该** 将 From 字段用于访问控制或认证，因为大多数接收方会认为该字段值是公共信息。

### 5.5.2. Referer

Referer"[sic]首部字段允许用户代理指定目标 URI 所来自的资源的 URI 参考（即 "referrer"，尽管该字段名称拼错了）。用户代理在生成 Referer 字段值时，**不得** 包括 URI 参考[RFC 3986]的片段和用户信息成分（如果有）。

```
Referer = absolute-URI / partial-URI
```

Referer 首部字段允许服务器生成到其他资源的反向链接，用于简单的分析、记录、优化缓存等。它还允许找到过时的或错误的链接进行维护。一些服务器使用 Referer 首部字段作为拒绝来自其他网站的链接（所谓的 "深层链接"）或限制跨站请求伪造（CSRF）的手段，但并非所有请求都包含它。

例子：

```http
Referer: http://www.example.org/hypertext/Overview.html
```

如果目标 URI 是从一个没有自己的 URI 的来源获得的（例如，从用户键盘输入，或在用户的书签/收藏夹中的条目），用户代理必须排除 Referer 字段或以 "about:blank" 的值发送它。

Referer 字段有可能揭示关于用户的请求上下文或浏览历史的信息，如果引用资源的标识符揭示了个人信息（如账户名）或本应保密的资源（如防火墙后面或安全服务的内部），这就是一个隐私问题。当引用资源是一个本地 "文件" 或 "数据 "URI 时，大多数通用的用户代理不发送 Referer 首部字段。如果引用的页面是用安全协议接收的，那么用户代理 **不得** 在不安全的 HTTP 请求中发送引用者首部字段。关于其他的安全考虑，见第 9.4 节。

一些中继已经知道不分青红皂白地从发出的请求中移除 Referer 首部字段。这有一个不幸的副作用，就是干扰了对 CSRF 攻击的保护，这对用户的危害更大。希望限制 Referer 信息披露的中继和用户代理扩展应该把他们的改变限制在特定的编辑上，例如用假名替换内部域名或截断查询和/或路径组件。当 Referer 首部字段的值与请求目标共享相同的方案和主机时，中继 **不应该** 修改或删除该字段。

### 5.5.3. User-Agent

"User-Agent" 首部字段包含了关于发起请求的用户代理的信息，这通常被服务器用来帮助识别报告的互操作性问题的范围，以解决或定制响应来避免特定的用户代理限制，并用于分析浏览器或操作系统的使用。用户代理 **应该** 在每个请求中发送一个 User-Agent 字段，除非特别配置为不这样做。

```
User-Agent = product *( RWS ( product / comment ) )
```

User-Agent 字段值由一个或多个产品标识符组成，每个标识符后面有零个或多个注释（[RFC 7230]第 3.2 节），它们共同标识了用户代理软件和它的重要子产品。根据惯例，产品标识符按其对识别用户代理软件的重要性的递减顺序列出。每个产品标识符由一个名称和可选的版本组成。

```
product = token ["/" product-version]
product-version = token
```

发送方 **应该** 将生成的产品标识符限制在识别产品所需的范围内；发送方 **不得** 在产品标识符中生成广告或其他非必要的信息。发送方 **不应该** 在产品版本中生成不是版本标识符的信息（即，同一产品名称的连续版本应该只在产品标识符的产品版本部分有所不同）。

例子：

```http
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
```

用户代理 **不应该** 生成包含不必要的细化细节的用户代理字段，并应限制第三方添加子产品。过长和过细的用户代理字段值会增加请求延迟和违背用户意愿被识别的风险（"指纹"）。

同样地，我们鼓励实现者不要为了声明与其他实现者的兼容性而使用其他实现者的产品标记，因为这规避了该字段的目的。如果一个用户代理伪装成一个不同的用户代理，接收方可以认为用户有意希望看到为该识别的用户代理定制的响应，即使这些响应对正在使用的实际用户代理可能不那么有效。

# 6. 响应状态码

status-code 元素是一个三位数的整数代码，给出试图理解和满足请求的结果。

HTTP 状态码是可扩展的。HTTP 客户不需要理解所有注册状态码的含义，尽管这种理解显然是可取的。然而，客户必须理解任何状态码的类别，如第一个数字所示，并将未识别的状态码视为等同于该类别的 x00 状态码，但接收方不得缓存未识别的状态码的响应。

例如，如果客户收到 471 的未识别状态码，客户可以认为其请求有问题，并把响应当作收到 400(Bad Request)的状态码。响应报文通常会包含一个解释状态的表述。

状态码的第一个数字定义了响应的类别。后面两个数字没有任何分类的作用。第一个数字有五个值：

- 1xx (Informational): 收到请求，继续处理
- 2xx (Successful): 该请求被成功接收、理解并接受
- 3xx (Redirection): 为了完成请求，需要采取进一步的动作
- 4xx (Client Error): 该请求包含错误的语法或无法完成
- 5xx (Server Error): 服务器未能满足一个明显有效的请求

## 6.1. 状态码概览

下面列出的状态码在本规范、[RFC 7232]的第 4 节、[RFC 7233]的第 4 节和[RFC 7235]的第 3 节中都有定义。这里列出的原因短语只是建议 -- 它们可以被本地的等价物取代而不影响协议。

除非方法定义或明确的缓存控制[RFC 7234]另有说明，否则状态码被定义为可缓存的响应（例如本规范中的 200、203、204、206、300、301、404、405、410、414 和 501）可以被具有启发式过期的缓存重复使用；所有其他状态码默认是不可缓存的。

| 状态码 | 原因短语                                    | 定义在              |
| ------ | ------------------------------------------- | ------------------- |
| 100    | Continue(继续)                              | 6.2.1 节            |
| 101    | Switching Protocols(交换协议)               | 6.2.2 节            |
| 200    | OK(顺利)                                    | 6.3.1 节            |
| 201    | Created(已创建)                             | 6.3.2 节            |
| 202    | Accepted(已接受)                            | 6.3.3 节            |
| 203    | Non-Authoritative Information(非权威性信息) | 6.3.4 节            |
| 204    | No Content(无内容)                          | 6.3.5 节            |
| 205    | Reset Content(重置内容)                     | 6.3.6 节            |
| 206    | Partial Content(部分内容)                   | [RFC 7233]的 4.1 节 |
| 300    | Multiple Choices(多重选择)                  | 6.4.1 节            |
| 301    | Moved Permanently(永久移动)                 | 6.4.2 节            |
| 302    | Found(已找到)                               | 6.4.3 节            |
| 303    | See Other(查看其他)                         | 6.4.4 节            |
| 304    | Not Modified(未修改)                        | [RFC 7232]的 4.1 节 |
| 305    | Use Proxy(使用代理)                         | 6.4.5 节            |
| 307    | Temporary Redirect(暂时重定向)              | 6.4.7 节            |
| 400    | Bad Request(错误请求)                       | 6.5.1 节            |
| 401    | Unauthorized(未经授权)                      | [RFC 7235]的 3.1 节 |
| 402    | Payment Required(需要付款)                  | 6.5.2 节            |
| 403    | Forbidden(禁止访问)                         | 6.5.3 节            |
| 404    | Not Found(未找到)                           | 6.5.4 节            |
| 405    | Method Not Allowed(不允许的方法)            | 6.5.5 节            |
| 406    | Not Acceptable(不接受)                      | 6.5.6 节            |
| 407    | Proxy Authentication Required(需要代理认证) | [RFC 7235]的 3.2 节 |
| 408    | Request Timeout(请求超时)                   | 6.5.7 节            |
| 409    | Conflict(冲突)                              | 6.5.8 节            |
| 410    | Gone(消失)                                  | 6.5.9 节            |
| 411    | Length Required(需要长度)                   | 6.5.10 节           |
| 412    | Precondition Failed(前提条件失败)           | [RFC 7232]的 4.2 节 |
| 413    | Payload Too Large(有效载荷太大)             | 6.5.11 节           |
| 414    | URI Too Long(URI 太长)                      | 6.5.12 节           |
| 415    | Unsupported Media Type(不支持的媒体类型)    | 6.5.13 节           |
| 416    | Range Not Satisfiable(范围不满足)           | [RFC 7233]的 4.4 节 |
| 417    | Expectation Failed(预期失败)                | 6.5.14 节           |
| 426    | Upgrade Required(需要升级)                  | 6.5.15 节           |
| 500    | Internal Server Error(内部服务器错误)       | 6.6.1 节            |
| 501    | Not Implemented(未实现)                     | 6.6.2 节            |
| 502    | Bad Gateway(网关错误)                       | 6.6.3 节            |
| 503    | Service Unavailable(服务不可用)             | 6.6.4 节            |
| 504    | Gateway Timeout(网关超时)                   | 6.6.5 节            |
| 505    | HTTP Version Not Supported(HTTP 版本不支持) | 6.6.6 节            |

请注意，这个列表并不详尽，它不包括其他规范中定义的扩展状态码。完整的状态码列表由 IANA 维护。详见第 8.2 节。

## 6.2. 信息 1xx

1xx (Informational)类状态码表示一种临时响应，用于在完成所请求的操作和发送最终响应之前沟通连接状态或请求进度。1xx 响应由状态行之后的第一个空行终止（空行标志着首部的结束）。由于 HTTP/1.0 没有定义任何 1xx 状态码，服务器必须不向 HTTP/1.0 客户发送 1xx 响应。

客户必须能够解析在最终响应之前收到的一个或多个 1xx 响应，即使客户不期望有这样的响应。用户代理可能会忽略意外的 1xx 响应。

代理必须转发 1xx 响应，除非代理本身要求生成 1xx 响应。例如，如果一个代理在转发请求时添加了一个 "Expect: 100-continue"字段，那么它就不需要转发相应的 100(Continue)响应。

### 6.2.1. 100 Continue

100(Continue)状态码表示已经收到了请求的初始部分，并且还没有被服务器拒绝。服务器打算在请求被完全接收并采取动作后发送一个最终响应。

当请求包含一个包含 100-continue 期望的 Expect 首部字段时，100 响应表示服务器希望接收请求的有效载荷，如 5.1.1 节所述。客户应该继续发送请求并丢弃 100 响应。

如果请求不包含包含 100-continue 期望的 Expect 首部字段，客户可以简单地丢弃这个临时响应。

### 6.2.2. 101 Switching Protocols

101(Switching Protocols)状态码表明服务器理解并愿意遵守客户通过 Upgrade 首部字段（[RFC 7230]第 6.7 节）提出的改变该连接上正在使用的应用协议的请求。服务器必须在响应中生成一个 Upgrade 首部字段，表明在结束 101 响应的空行之后将立即切换到哪个协议。

假设服务器只在有利的情况下同意切换协议。例如，切换到较新版本的 HTTP 可能比旧版本更有优势，而切换到实时、同步协议可能在交付使用此类功能的资源时更有优势。

## 6.3. 成功 2xx

2xx(Successful)类状态码表明客户的请求被成功接收、理解和接受。

### 6.3.1. 200 OK

200(OK)状态码表明请求已经成功。200 响应中发送的有效载荷取决于请求方法。对于本规范定义的方法，有效载荷的预期含义可以总结为：

GET 目标资源的表示。
HEAD 与 GET 相同的表示，但没有表示数据。
POST 表示动作的状态，或从动作中获得的结果。
PUT, DELETE 表示动作的状态。
OPTIONS：通信选项的表示。
TRACE 表示终端服务器所收到的请求报文。

除了对 CONNECT 的响应外，200 响应总是有一个有效载荷，尽管源服务器可以生成一个零长度的有效载荷。如果不需要有效载荷，源服务器应该发送 204（无内容）来代替。对于 CONNECT，不允许有有效载荷，因为成功的结果是一个隧道，它紧接着 200 响应首部开始。

200 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有说明（见[RFC 7234]的第 4.2.2 节）。

### 6.3.2. 201 Created

201(Created)状态码表示请求已经完成，并导致一个或多个新资源被创建。请求创建的主要资源由响应中的 Location 首部字段确定，如果没有收到 Location 字段，则由有效请求 URI 确定。

201 响应的有效载荷通常描述并链接到创建的资源。关于 201 响应中验证器首部字段（如 ETag 和 Last-Modified）的含义和目的的讨论，见第 7.2 节。

### 6.3.3. 202 Accepted

202 (Accepted) 状态码表示该请求已被接受处理，但处理尚未完成。该请求最终可能被处理，也可能不被处理，因为当处理实际发生时，它可能被不允许。在 HTTP 中没有任何设施可以从一个异步操作中重新发送状态码。

202 响应是故意不承诺的。它的目的是允许服务器接受其他进程的请求（也许是一个每天只运行一次的面向批处理的进程），而不要求用户代理与服务器的连接持续到该进程完成。与该响应一起发送的表述应该描述请求的当前状态，并指向（或嵌入）一个状态监视器，该监视器可以向用户提供请求何时被满足的估计。

### 6.3.4. 203 Non-Authoritative Information

203(Non-Authoritative Information)状态码表明请求是成功的，但所附的有效载荷已经被转换代理从源服务器的 200(OK)响应中修改了（[RFC 7230]第 5.7.2 节）。这个状态码允许代理在应用转换时通知接收方，因为这种知识可能会影响以后关于内容的决定。例如，未来对该内容的缓存验证请求可能只适用于沿同一请求路径（通过相同的代理）。

203 响应类似于 214 转换应用的警告代码（[RFC 7234]第 5.5 节），它的优点是适用于任何状态码的响应。

203 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有说明（见[RFC 7234]的第 4.2.2 节）。

### 6.3.5. 204 No Content

204(No Content)状态码表示服务器已经成功地完成了请求，并且在响应有效载荷中没有额外的内容可以发送。响应首部字段中的元数据指的是目标资源及其在应用所请求的操作后的选定表示。

例如，如果在响应 PUT 请求时收到 204 状态码，并且响应包含 ETag 首部字段，那么 PUT 是成功的，ETag 字段值包含该目标资源的新表示的实体标记。

204 响应允许服务器表明该动作已经成功地应用于目标资源，同时暗示用户代理不需要从其当前的 "文档视图"（如果有的话）中穿越。服务器假定用户代理将按照它自己的界面向它的用户提供一些成功的指示，并将响应中的任何新的或更新的元数据应用到它的活动表示中。

例如，204 状态码通常用于与 "保存"操作相对应的文档编辑界面，这样被保存的文档仍然可以供用户编辑。它也经常用于期望自动数据传输盛行的界面，如分布式版本控制系统内。

204 响应由首部字段后的第一个空行结束，因为它不能包含报文体。

204 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有说明（见[RFC 7234]的 4.2.2 节）。

### 6.3.6. 205 Reset Content

205(Reset Content)状态码表明服务器已经完成了请求，并希望用户代理将导致请求被发送的 "文档视图" 重置为从源服务器收到的原始状态。

这个响应旨在支持一个常见的数据输入用例，即用户收到支持数据输入的内容（表格、记事本、画布等），在该空间中输入或操作数据，使输入的数据在请求中提交，然后为下一个输入重置数据输入机制，以便用户可以轻松地启动另一个输入动作。

由于 205 状态码意味着将不提供额外的内容，服务器 **必须** 不在 205 响应中生成有效载荷。换句话说，服务器 **必须** 对 205 响应采取以下措施之一：a）通过包括一个值为 0 的 Content-Length 首部字段来表示响应的零长度主体；b）通过包括一个值为 chunked 的 Transfer-Encoding 首部字段和一个由零长度的单一块组成的消息主体来表示响应的零长度有效载荷；或者，c）在发送结束首部的空白行后立即关闭连接。

## 6.4. 重定向 3xx

3xx (Redirection)类状态码表明用户代理需要采取进一步的行动以满足请求。如果提供了 Location 首部字段（第 7.1.2 节），用户代理 **可以** 自动将其请求重定向到 Location 字段值所引用的 URI，即使特定的状态码不被理解。对于第 4.2.1 节中定义的不安全的方法，需要谨慎地进行自动重定向，因为用户可能不希望重定向一个不安全的请求。

有几种类型的重定向：

1. 重定向表示该资源可能在不同的 URI 上可用，如 Location 字段提供的状态码 301(Moved Permanently)、302(Found)和 307(Temporary Redirect)。
2. 提供匹配资源选择的重定向，每个资源都能代表原始请求目标，如 300(Multiple Choices)状态码。
3. 重定向到一个不同的资源，由 Location 字段确定，可以代表对请求的间接响应，如 303(See Other)状态码。
4. 重定向到一个先前的缓存结果，如 304(Not Modified)状态码。

注意：在 HTTP/1.0 中，状态码 301(Moved Permanently)和 302(Found)被定义为第一类重定向（[RFC 1945]，9.3 节）。早期的用户代理在应用于重定向目标的方法是否与原始请求相同或被改写为 GET 上存在分歧。尽管 HTTP 最初为 301 和 302 定义了前一种语义（以配合其在 CERN 的原始实现），并为 303(See Other)定义了后一种语义，但普遍的做法是对 301 和 302 也逐渐趋于后一种语义。HTTP/1.1 的第一次修订增加了 307(Temporary Redirect)，以表示前者的语义，而不被不同的实践所影响。10 多年后，大多数用户代理仍然对 301 和 302 进行方法重写；因此，本规范使这种行为在原始请求为 POST 时符合要求。

客户 **应该** 检测并干预循环重定向（即，"无限" 重定向循环）。

注意：本规范的早期版本建议最多有五个重定向（[RFC 2068]，第 10.3 节）。内容开发者需要注意的是，一些客户可能会实现这样的固定限制。

### 6.4.1. 300 Multiple Choices

300(Multiple Choices)状态码表示目标资源有一个以上的表示，每个表示都有它自己的更具体的标识符，关于替代方案的信息正在被提供，以便用户（或用户代理）可以通过将其请求重定向到这些标识符中的一个或多个来选择一个首选表示。换句话说，服务器希望用户代理参与反应性的协商，以选择最适合其需求的表示（第 3.4 节）。

如果服务器有一个优先选择，服务器 **应该** 生成一个包含优先选择的 URI 参考的 Location 首部字段。用户代理可以使用 Location 字段的值进行自动重定向。

对于 HEAD 以外的请求方法，服务器 **应该** 在 300 响应中生成一个有效载荷，其中包含一个表示元数据和 URI 引用的列表，用户或用户代理可以从中选择最喜欢的一个。如果用户代理理解所提供的媒体类型，它可以从该列表中自动进行选择。本规范没有定义自动选择的具体格式，因为 HTTP 试图保持对其有效载荷定义的正交性。在实践中，表示法是以一些容易解析的格式提供的，相信是用户代理可以接受的，这是由共享设计或内容协商决定的，或以一些普遍接受的超文本格式提供。

300 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有说明（见[RFC 7234]的第 4.2.2 节）。

注意：关于 300 状态码的最初提议将 URI 首部字段定义为提供替代表示的列表，这样它就可以用于 200、300 和 406 响应，并在对 HEAD 方法的响应中传输。然而，由于缺乏部署和对语法的分歧，导致 URI 和 Alternates（一个后续的提议）都从这个规范中删除。有可能使用一组链接首部字段[RFC 5988]来通信列表，每个字段都有 "交替" 的关系，尽管部署是一个"先有鸡还是先有蛋"的问题。

### 6.4.2. 301 Moved Permanently

301(Moved Permanently)状态码表明，目标资源已经被分配了一个新的永久 URI，今后对该资源的任何引用都应该使用其中的一个 URI。具有链接编辑功能的客户应该尽可能地将对有效请求 URI 的引用自动重新链接到服务器发送的一个或多个新的引用。

服务器 **应该** 在响应中生成一个包含新的永久 URI 的首选 URI 引用的 Location 首部字段。用户代理 **可以** 使用 Location 字段的值进行自动重定向。服务器的响应有效载荷通常包含一个简短的超文本说明，其中有一个指向新 URI 的超链接。

注意：由于历史原因，用户代理可能会将后续请求的请求方法从 POST 改为 GET。如果不希望出现这种行为，可以使用 307(Temporary Redirect)状态码来代替。

301 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有指示（见[RFC 7234]第 4.2.2 节）。

### 6.4.3. 302 Found

302(Found)状态码表明目标资源暂时停留在一个不同的 URI 下。由于重定向有时会被改变，客户应该继续使用有效的请求 URI 来处理未来的请求。

服务器 **应该** 在响应中生成一个包含不同 URI 参考的 Location 首部字段。用户代理 **可以** 使用 Location 字段的值进行自动重定向。服务器的响应有效载荷通常包含一个简短的超文本说明，其中有一个指向不同 URI 的超链接。

注意：由于历史原因，用户代理 **可以** 将后续请求的请求方法从 POST 改为 GET。如果不希望出现这种行为，可以使用 307(Temporary Redirect)状态码来代替。

### 6.4.4. 303 See Other

303(See Other)状态码表示服务器正在将用户代理重定向到一个不同的资源，如 Location 首部字段中的 URI 所示，该资源旨在对原始请求提供间接响应。用户代理 **可以** 执行针对该 URI 的检索请求（如果使用 HTTP，则为 GET 或 HEAD 请求），该请求也可能被重定向，并将最终的结果作为对原始请求的回答。注意，Location 首部字段中的新 URI 不被认为等同于有效的请求 URI。

这个状态码适用于任何 HTTP 方法。它主要用于允许 POST 动作的输出将用户代理重定向到一个选定的资源，因为这样做提供了与 POST 响应相对应的信息，其形式可以被单独识别、添加书签和缓存，与原始请求无关。

对 GET 请求的 303 响应表明源服务器没有可以由服务器通过 HTTP 传输的目标资源的表示。然而，Location 字段的值指的是描述目标资源的资源，这样，在其他资源上提出检索请求可能会产生对接收方有用的表示，而不意味着它代表原始目标资源。请注意，对于什么可以被代表，什么代表是充分的，以及什么可能是有用的描述等问题的答案是在 HTTP 的范围之外。

除了对 HEAD 请求的响应外，303 响应的表示应该包含一个简短的超文本说明，其中有一个指向 Location 首部字段中提供的相同 URI 引用的超链接。

### 6.4.5. 305 Use Proxy

305(Use Proxy)状态码是在本规范的前一个版本中定义的，现在已经废弃了（附录 B）。

### 6.4.6. 306 (Unused)

306 状态码是在本规范的前一个版本中定义的，现在已经不再使用，该号码被保留。

### 6.4.7. 307 Temporary Redirect

307(Temporary Redirect)状态码表示目标资源暂时停留在一个不同的 URI 下，如果用户代理执行自动重定向到该 URI，则不得改变请求方法。由于重定向可能会随着时间的推移而改变，客户 **应该** 继续使用原来的有效请求 URI 来处理未来的请求。

服务器 **应该** 在响应中生成一个包含不同 URI 参考的 Location 首部字段。用户代理 **可以** 使用 Location 字段的值进行自动重定向。服务器的响应有效载荷通常包含一个简短的超文本说明，其中有一个指向不同 URI 的超链接。

注意：这个状态码类似于 302(Found)，除了它不允许将请求方法从 POST 改为 GET。本规范没有为 301(Moved Permanently)定义等效的对应代码（然而，[RFC 7238]为此目的定义了状态码 308(Permanent Redirect)）。

## 6.5. 客户错误 4xx

4xx(Client Error)类状态码表示客户似乎出了错。除了在响应 HEAD 请求时，服务器 **应该** 发送一个包含错误情况解释的表示，以及它是一个临时的还是永久的情况。这些状态码适用于任何请求方法。用户代理 **应该** 向用户显示任何包含的表示。

### 6.5.1. 400 Bad Request

400(Bad Request)状态码表示服务器不能或不会处理该请求，原因是被认为是客户的错误（例如，畸形的请求语法，无效的请求报文分帧，或欺骗性的请求路由）。

### 6.5.2. 402 Payment Required

402(Payment Required)状态码是为将来使用而保留的。

### 6.5.3. 403 Forbidden

403(Forbidden)状态码表示服务器理解该请求，但拒绝授权。希望公开该请求被禁止的原因的服务器 **可以** 在响应的有效载荷中描述该原因（如果有的话）。

如果在请求中提供了认证凭证，服务器认为它们不足以授予访问权。客户 **不应该** 自动用相同的凭证重复请求。客户 **可以 **用新的或不同的凭证重复请求。然而，一个请求可能由于与凭证无关的原因而被禁止。

希望 "隐藏" 当前存在的被禁止的目标资源的源服务器，**可以** 用 404(Not Found)的状态码来响应。

### 6.5.4. 404 Not Found

404(Not Found)状态码表示源服务器没有找到目标资源的当前表示，或者不愿意透露存在这样的表示。404 状态码并不表明这种缺乏代表性是暂时的还是永久的；如果源服务器知道，大概是通过一些可配置的手段，这种情况可能是永久的，那么 410(Gone)状态码比 404 更受欢迎。

404 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有指示（见[RFC 7234]第 4.2.2 节）。

### 6.5.5. 405 Method Not Allowed

405(Method Not Allowed)状态码表示请求行中收到的方法被源服务器知道，但不被目标资源支持。源服务器 **必须** 在 405 响应中生成一个包含目标资源当前支持的方法列表的 Allow 首部字段。

405 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有指示（见[RFC 7234]第 4.2.2 节）。

### 6.5.6. 406 Not Acceptable

406(406 Not Acceptable)状态码表明，根据请求（第 5.3 节）中收到的主动协商首部字段，目标资源没有用户代理可以接受的当前表示，并且服务器不愿意提供默认表示。

服务器 **应该** 生成一个包含可用表示特性和相应资源标识符的列表的有效载荷，用户或用户代理可以从中选择最合适的表示。用户代理 **可以** 从该列表中自动选择最合适的选择。然而，本规范没有为这种自动选择定义任何标准，如第 6.4.1 节中所述。

### 6.5.7. 408 Request Timeout

408(Request Timeout)状态码表示服务器在它准备等待的时间内没有收到完整的请求信息。服务器 **应该** 在响应中发送 "关闭" 连接选项（[RFC 7230]第 6.1 节），因为 408 意味着服务器已经决定关闭连接而不是继续等待。如果客户有一个正在传输的请求，客户可以在一个新的连接上重复该请求。

### 6.5.8. 409 Conflict

409(Conflict) 状态码表示由于与目标资源的当前状态冲突，请求无法完成。该代码用于用户可能能够解决冲突并重新提交请求的情况。服务器 **应该** 生成一个有效载荷，其中包括足够的信息，使用户能够识别冲突的来源。

冲突最可能发生在对 PUT 请求的响应中。例如，如果正在使用版本管理，并且被 PUT 的表示包括对资源的修改，而这些修改与先前（第三方）请求所做的修改相冲突，那么源服务器 **可以** 使用 409 响应来表示它不能完成请求。在这种情况下，响应表示可能包含对基于修订历史合并差异有用的信息。

### 6.5.9. 410 Gone

410 (Gone)状态码表明，对目标资源的访问在源服务器上不再可用，而且这种情况可能是永久性的。如果源服务器不知道，或者没有设施来确定这种情况是否是永久性的，**应该** 使用状态码 404(Not Found)来代替。

410 响应主要是为了协助网络维护工作，通知接收方该资源是故意不可用的，并且服务器所有者希望删除该资源的远程链接。这样的事件对于有限的时间、促销服务和属于不再与原服务器网站相关的个人的资源来说是常见的。没有必要将所有永久不可用的资源标记为 "消失"，也没有必要将标记保留多长时间--这要由服务器所有者决定。

410 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有指示（见[RFC 7234]第 4.2.2 节）。

### 6.5.10. 411 Length Required

411 (Length Required) 状态码表示服务器拒绝接受没有定义内容长度的请求（[RFC 7230] 第 3.3.2 节）。如果客户在请求报文中添加一个有效的包含报文体长度的 Content-Length 首部字段，则可以重复请求。

### 6.5.11. 413 Payload Too Large

413 (Payload Too Large)状态码表示服务器拒绝处理一个请求，因为请求的有效载荷比服务器愿意或能够处理的大。服务器 **可以** 关闭连接以防止客户继续请求。

如果该状况是暂时的，服务器 **应该** 生成一个 Retry-After 首部字段，以表明它是暂时的，以及在什么时间之后客户可以再次尝试。

### 6.5.12. 414 URI Too Long

414 (URI Too Long) 状态码表明服务器拒绝为请求提供服务，因为请求目标（[RFC 7230]第 5.3 节）比服务器愿意解释的要长。这种罕见的情况只有在以下情况下才可能发生：客户不适当地将 POST 请求转换为带有长查询信息的 GET 请求，客户陷入重定向的 "黑洞"（例如，重定向的 URI 前缀指向自身的后缀），或者服务器受到试图利用潜在安全漏洞的客户攻击。

414 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有说明（见[RFC 7234]第 4.2.2 节）。

### 6.5.13. 415 Unsupported Media Type

415(Unsupported Media Type)状态码表明，源服务器拒绝为请求提供服务，因为有效载荷的格式不被目标资源上的这种方法所支持。格式问题可能是由于请求所表明的 Content-Type 或 Content-Encoding，或直接检查数据的结果。

### 6.5.14. 417 Expectation Failed

417 (Expectation Failed)状态码表示请求的 Expect 首部字段（第 5.1.1 节）中给出的期望不能被至少一个入站服务器满足。

### 6.5.15. 426 Upgrade Required

426 (Upgrade Required)状态码表示服务器拒绝使用当前协议执行请求，但在客户升级到不同的协议后可能愿意这样做。服务器必须在 426 响应中发送一个 Upgrade 首部字段以指示所需的协议（[RFC 7230]第 6.7 节）。

例子：

```http
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.
```

## 6.6. 服务器错误 5xx

5xx (Server Error)类状态码表示服务器意识到它已经出错或无法执行请求的方法。除了在响应 HEAD 请求时，服务器应该发送一个包含对错误情况的解释的表示，以及它是一个临时的还是永久的情况。用户代理 **应该** 向用户显示任何包含的表示。这些响应码适用于任何请求方法。

### 6.6.1. 500 Internal Server Error

500(Internal Server Error)状态码表明服务器遇到了一个意外情况，使其无法满足请求。

### 6.6.2. 501 Not Implemented

501 (Not Implemented) 状态码表示服务器不支持满足请求的功能。当服务器不能识别请求方法并且不能支持任何资源时，这就是适当的响应。

501 响应默认是可缓存的；也就是说，除非方法定义或明确的缓存控制另有说明（见[RFC 7234]的第 4.2.2 节）。

### 6.6.3. 502 Bad Gateway

502(Bad Gateway)状态码表明，服务器在作为网关或代理时，在试图满足请求时从其访问的入站服务器收到了一个无效的响应。

### 6.6.4. 503 Service Unavailable

503(Service Unavailable)状态码表示服务器目前由于暂时的过载或计划中的维护而无法处理该请求，这可能会在一些延迟后得到缓解。服务器 **可以** 发送一个 Retry-After 首部字段（第 7.1.3 节），以建议客户在重试请求前等待的适当时间。

注意：503 状态码的存在并不意味着服务器在变得过载时必须使用它。有些服务器可能只是拒绝连接。

### 6.6.5. 504 Gateway Timeout

504(Gateway Timeout)状态码表明，服务器在作为网关或代理时，没有从它需要访问的上游服务器及时收到响应，以完成请求。

### 6.6.6. 505 HTTP Version Not Supported

505(HTTP Version Not Supported)状态码表示服务器不支持或拒绝支持请求信息中使用的 HTTP 主要版本。服务器表示它不能或不愿意使用与客户相同的主要版本来完成请求，如[RFC 7230]的第 2.6 节所述，而不是用这个错误信息。服务器 **应该** 为 505 响应生成一个表示，说明为什么不支持该版本以及该服务器支持哪些其他协议。

# 7. 响应首部字段

响应首部字段允许服务器传递关于响应的额外信息，而不是放在状态行中的内容。这些首部字段给出了关于服务器、对目标资源的进一步访问或相关资源的信息。

尽管每个响应首部字段都有明确的含义，但一般来说，精确的语义可能会被请求方法和/或响应状态码的语义进一步完善。

## 7.1. 控制数据

响应首部字段可以提供控制数据，以补充状态码，指导缓存，或指示客户的下一步行动。

| 首部字段名    | 定义在              |
| ------------- | ------------------- |
| Age           | [RFC 7234]的 5.1 节 |
| Cache-Control | [RFC 7234]的 5.2 节 |
| Expires       | [RFC 7234]的 5.3 节 |
| Date          | 7.1.1.2 节          |
| Location      | 7.1.2 节            |
| Retry-After   | 7.1.3 节            |
| Vary          | 7.1.4 节            |
| Warning       | [RFC 7234]节        |

### 7.1.1. 发起日期

#### 7.1.1.1. 日期/时间 格式

在 1995 年之前，有三种不同的格式，通常被服务器用来通信时间戳。为了与旧的实现兼容，这里定义了所有三种格式。首选的格式是 Internet 报文格式[RFC 5322]所使用的日期和时间规范的一个固定长度和单区子集。

```
HTTP-date = IMF-fixdate / obs-date
```

首选格式的一个例子是：

```http
Sun, 06 Nov 1994 08:49:37 GMT ; IMF-fixdate
```

这两种废弃的格式的例子是：

```http
Sunday, 06-Nov-94 08:49:37 GMT ; obsolete RFC 850 format
Sun Nov 6 08:49:37 1994 ; ANSI C’s asctime() format
```

在 HTTP 首部字段中解析时间戳值的接收方必须接受所有三种 HTTP-date 格式。当发送方生成一个包含一个或多个定义为 HTTP-date 的时间戳的首部字段时，发送方必须以 IMF-fixdate 格式生成这些时间戳。

一个 HTTP-date 值表示时间为协调世界时（UTC）的一个实例。前两种格式用格林威治时间的三个字母缩写 "GMT "来表示 UTC，这是 UTC 名称的前身；asctime 格式的值被认为是 UTC 的。从本地时钟生成 HTTP-date 值的发送方应该使用 NTP（[RFC 5905]）或一些类似的协议来使其时钟与 UTC 同步。

首选格式：

```
IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT ; fixed length/zone/capitalization subset of the format ; 见 [RFC 5322]的 3.3节

day-name = %x4D.6F.6E ; "Mon", case-sensitive
          / %x54.75.65 ; "Tue", case-sensitive
          / %x57.65.64 ; "Wed", case-sensitive
          / %x54.68.75 ; "Thu", case-sensitive
          / %x46.72.69 ; "Fri", case-sensitive
          / %x53.61.74 ; "Sat", case-sensitive
          / %x53.75.6E ; "Sun", case-sensitive

date1 = day SP month SP year
        ; e.g., 02 Jun 1982

day = 2DIGIT
month = %x4A.61.6E ; "Jan", case-sensitive
        / %x46.65.62 ; "Feb", case-sensitive
        / %x4D.61.72 ; "Mar", case-sensitive
        / %x41.70.72 ; "Apr", case-sensitive
        / %x4D.61.79 ; "May", case-sensitive
        / %x4A.75.6E ; "Jun", case-sensitive
        / %x4A.75.6C ; "Jul", case-sensitive
        / %x41.75.67 ; "Aug", case-sensitive
        / %x53.65.70 ; "Sep", case-sensitive
        / %x4F.63.74 ; "Oct", case-sensitive
        / %x4E.6F.76 ; "Nov", case-sensitive
        / %x44.65.63 ; "Dec", case-sensitive
year = 4DIGIT

GMT = %x47.4D.54 ; "GMT", case-sensitive

time-of-day = hour ":" minute ":" second
              ; 00:00:00 - 23:59:60 (leap second)

hour = 2DIGIT
minute = 2DIGIT
second = 2DIGIT
```

废弃格式：

```
obs-date = rfc850-date / asctime-date

rfc850-date = day-name-l "," SP date2 SP time-of-day SP GMT
date2 = day "-" month "-" 2DIGIT ; e.g., 02-Jun-82

day-name-l = %x4D.6F.6E.64.61.79 ; "Monday", case-sensitive
            / %x54.75.65.73.64.61.79 ; "Tuesday", case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday", case-sensitive
            / %x54.68.75.72.73.64.61.79 ; "Thursday", case-sensitive
            / %x46.72.69.64.61.79 ; "Friday", case-sensitive
            / %x53.61.74.75.72.64.61.79 ; "Saturday", case-sensitive
            / %x53.75.6E.64.61.79 ; "Sunday", case-sensitive

asctime-date = day-name SP date3 SP time-of-day SP year
date3 = month SP ( 2DIGIT / ( SP 1DIGIT )) ; e.g., Jun 2
```

#### 7.1.1.2. Date

"Date" 首部字段代表了报文产生的日期和时间，与[RFC 5322]第 3.6.1 节中定义的起源日期字段（origination-date）具有相同的语义。该字段的值是 HTTP-date，定义在第 7.1.1.1 节。

```
Date = HTTP-date
```

一个例子是：

```http
Date: Tue, 15 Nov 1994 08:12:31 GMT
```

当生成 Date 首部字段时，发送方 **应该** 将其字段值作为报文生成日期和时间的最佳可用近似值。在理论上，日期应该代表在生成有效载荷之前的时刻。在实践中，日期可以在报文产生的任何时候产生。

如果源服务器没有能够提供协调世界时中的当前实例的合理近似值的时钟，则 **不得** 发送 Date 首部字段。如果响应属于 1xx(Informational)或 5xx(Server Error)类状态码，源服务器 **可以** 发送 Date 首部字段。在所有其他情况下，源服务器 **必须** 发送一个 Date 首部字段。

有时钟的接收方在收到没有 Date 首部字段的响应报文时 **必须** 记录它被收到的时间，并且如果它被缓存或转发到下游，则将相应的 Date 首部字段附加到报文的首部。

用户代理 **可以** 在请求中发送一个 Date 首部字段，但通常不会这样做，除非它被认为会向服务器传达有用的信息。例如，如果服务器被期望根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，那么 HTTP 的定制应用可能会传达一个日期。

### 7.1.2. Location

"Location"首部字段在一些响应中被用来指代与响应有关的特定资源。关系的类型由请求方法和状态码语义的组合来定义。

```
Location = URI-reference
```

该字段值由单个 URI-reference 组成。当它具有相对引用的形式时（[RFC 3986]，第 4.2 节），最终值是通过对有效请求 URI（[RFC 3986]，第 5 节）进行解析来计算的。

对于 201(Created)响应，Location 值指的是由请求创建的主要资源。对于 3xx(Redirection) 响应，Location 值指的是自动重定向请求的首选目标资源。

如果在 3xx(Redirect)响应中提供的 Location 值没有 Fragment 部分，用户代理 **必须** 处理重定向，就好像该值继承了用于生成请求目标的 URI 引用的 Fragment 部分（即，重定向继承了原始引用的片段，如果有的话）。

例如，为 URI 引用 "http://www.example.org/˜tim "生成的 GET 请求可能导致一个包含首部字段的 303(See Other)响应。

```http
Location: /People.html#tim
```

这建议用户代理重定向到 "http://www.example.org/People.html#tim"

同样，为 URI-reference "http://www.example.org/index.html#larry" 产生的一个 GET 请求可能会导致一个包含首部字段的 301(Moved Permanently)响应。

```http
Location: http://www.example.net/index.html
```

它建议用户代理重定向到 "http://www.example.net/index.html#larry"，保留原始片段标识符。

在有些情况下，Location 值中的片段标识符是不合适的。例如，201(Created)响应中的 Location 首部字段应该提供一个特定于创建资源的 URI。

注意：一些接收方试图从不是有效的 URI 引用的 Location 字段中恢复。本规范没有强制要求或定义这种处理，但为了稳健起见，允许这样做。

注意：Content-Location 首部字段（第 3.1.4.2 节）与 Location 不同的是，Content-Location 指的是与所附表示法相对应的最具体资源。因此，一个响应有可能同时包含 Location 和 Content-Location 首部字段。

### 7.1.3. Retry-After

服务器发送 "Retry-After" 首部字段，以表明用户代理在发出后续请求之前应该等待多长时间。当与 503(Service Unavailable)响应一起发送时，Retry-After 表示服务对客户端预计不可用多长时间。当与任何 3xx(Redirect)响应一起发送时，Retry-After 表示用户代理在发出重定向请求之前被要求等待的最小时间。

这个字段的值可以是一个 HTTP 日期，也可以是收到响应后的延迟秒数。

```
Retry-After = HTTP-date / delay-seconds
```

延迟秒值是一个非负的十进制整数，代表以秒为单位的时间。

```
delay-seconds = 1*DIGIT
```

其使用的两个例子是：

```http
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
```

其中的第 2 个例子，延迟为 2 分钟。

### 7.1.4. Vary

响应中的 "Vary" 首部字段描述了除了方法、Host 首部字段和请求目标之外，请求报文的哪些部分可能会影响源服务器对该响应的选择和表示过程。该值由单个星号（"\*"）或首部字段名称的列表组成（不区分大小写）。

```
Vary = "*" / 1#field-name
```

Vary 字段的值为"/\*"，表示关于请求的任何东西都可能在选择响应表示中起作用，可能包括报文语法以外的元素（例如，客户的网络地址）。如果不把请求转发给源服务器，接收方将无法确定这个响应是否适合以后的请求。代理不可以生成具有"\*"值的 Vary 字段。

由逗号分隔的名称列表组成的 Vary 字段值表示被命名的请求首部字段（被称为选择首部字段）可能在选择表示方面有作用。潜在的选择首部字段不限于本规范所定义的那些。

例如，一个包含以下内容的响应：

```http
Vary: accept-encoding, accept-language
```

表示源服务器在选择这个响应的内容时，可能使用了请求的 Accept-Encoding 和 Accept-Language 字段（或没有这些字段）作为决定因素。

源服务器可能会出于两个目的发送 Vary 与字段列表。

1. 通知缓冲接收方，他们不应该使用这个响应来满足后来的请求，除非后来的请求与原始请求有相同的字段值（[RFC 7234]的第 4.1 节）。换句话说，Vary 扩展了将新请求与存储的缓存条目相匹配所需的缓存密钥。
2. 告知用户代理接收方，该响应受制于内容协商（第 5.3 节），如果在列出的首部字段中提供额外的参数，则可能在后续请求中发送不同的表示（主动协商）。

当源服务器选择表示法的算法根据请求报文中除方法和请求目标以外的其他方面发生变化时，源服务器应该发送 Vary 首部字段，除非这种变化不能被跨越，或者源服务器被故意配置为防止缓存透明。例如，没有必要在 Vary 中发送授权字段名，因为跨用户的重用受到字段定义的限制（[RFC 7235]第 4.2 节）。同样地，如果一个源服务器认为 Vary 的差异比 Vary 对缓存的影响所带来的性能代价要小，它可以使用 Cache-Control 指令（[RFC 7234]第 5.2 节）来取代 Vary。

## 7.2. 验证器首部字段

验证器首部字段传达关于所选表示的元数据（第 3 节）。在对安全请求的响应中，验证器字段描述了源服务器在处理响应时选择的表示法。请注意，根据状态码语义，给定响应的选定表示法不一定与作为响应有效载荷的表示法相同。

在对状态改变的请求的成功响应中，验证器字段描述了由于处理该请求而取代先前选定的表示的新表示。

例如，201(Created)响应中的 ETag 首部字段传达了新创建的资源表示的实体标记，这样它就可以在以后的条件请求中使用，以防止 "丢失的更新" 问题[RFC 7232]。

| 首部字段名    | 定义在              |
| ------------- | ------------------- |
| ETag          | [RFC 7232]的 2.3 节 |
| Last-Modified | [RFC 7232]的 2.2 节 |

## 7.3. 认证挑战

认证挑战表明有哪些机制可供客户在未来请求中提供认证凭证。

| 首部字段名         | 定义在              |
| ------------------ | ------------------- |
| WWW-Authenticate   | [RFC 7235]的 4.1 节 |
| Proxy-Authenticate | [RFC 7235]的 4.3 节 |

## 7.4. 响应环境

The remaining response header fields provide more information about the target resource for potential use in later requests.

| 首部字段名    | 定义在              |
| ------------- | ------------------- |
| Accept-Ranges | [RFC 7233]的 2.3 节 |
| Allow         | 7.4.1 节            |
| Server        | 7.4.2 节            |

### 7.4.1. Allow

"Allow" 首部字段列出了目标资源所支持的一系列方法的通告。这个字段的目的是严格告知接收方与该资源相关的有效请求方法。

```
Allow = #method
```

使用的例子：

```http
Allow: GET, HEAD, PUT
```

允许的方法的实际集合由源服务器在每个请求时定义。源服务器 **必须** 在 405(Method Not Allowed)响应中生成一个允许字段，并且可以在任何其他响应中这样做。一个空的 Allow 字段值表示该资源不允许任何方法，如果该资源因配置而被暂时禁用，这可能会在 405 响应中出现。

代理 **不得** 修改 Allow 首部字段--它不需要了解所有指示的方法，以便根据通用报文处理规则来处理它们。

### 7.4.2. Server

"Server" 首部字段包含了源服务器用来处理请求的软件的信息，这通常被客户用来帮助识别报告的互操作性问题的范围，以解决或定制请求以避免特定的服务器限制，以及用于分析服务器或操作系统的使用。源服务器可以在其响应中生成一个服务器字段。

```
Server = product *( RWS ( product / comment ) )
```

服务器字段值由一个或多个产品标识符组成，每个标识符后面有零个或多个注释（[RFC 7230]第 3.2 节），它们共同标识了源服务器软件和它的重要子产品。根据惯例，产品标识符按其对识别源服务器软件的重要性的递减顺序列出。每个产品标识符由名称和可选的版本组成，如第 5.5.3 节中所定义。

例子：

```http
Server: CERN/3.0 libwww/2.17
```

源服务器不应生成包含不必要的细粒度细节的服务器字段，并应限制第三方添加子产品。过长和详细的服务器字段值会增加响应延迟，并有可能揭示内部实施细节，这可能使攻击者更容易发现和利用已知的安全漏洞。
